DBMS(DataBase MAnagement System)
 - 데이터 베이스를 관리해주는 프로그램
 - 다수의 사용자들이 데이터베이스 내의 
    데이터를 접근할 수 있도록 해주는 소프트웨어 도구의 집합

Schema : 연관된 테이블들을 그룹핑하는 일종의 디렉토리(폴더)
사용자 : 사용자를 생성하면 사용자에 속하는 스키마가 만들어지고
	  사용자는 그 안에 있는 테이블에 접속할 수 있음
※ 사용자 = 스키마는 아니지만 둘은 항상 세트

SQL(Structured Query Language)
 - 데이터 베이스에 명령을 주는 것
       구조화된 정보를 처리하도록 요청하는 컴퓨터 언어
 - 엑셀보다 불편하고 어려운데 DB를 사용하는 이유
   · 물리적 한계
        엑셀은 물리적으로 많은 데이터를 넣기가 힘들다. 최대 65000여개

   · 명령어를 통해 DB를 제어할 수 있다
        명령어를 컴퓨터 프로그램을 통해 데이터를 자동적으로 만들 수 있다.
        명령어를 통해 데이터를 가공하고 가치있는 무언가를 만드는 것을 자동화 할 수 있다.

SQL 명령어의 유형
 - DQL(Data Query Language, 질의어)
   · SELECT : 데이터 검색시 사용★★★
 
 - DML(Data Manipulation Language, 데이터 조작어)
   · INSERT : 데이터 입력
   · UPDATE : 데이터 수정
   · DELETE : 데이터 삭제

 - DDL(Data Definition Language, 데이터 정의어)
   · CREATE : 데이터베이스 생성
   · ALTER : 데이터베이스 변경, 기존의 테이블 수정(추가, 크기변경 등)
   · DROP : 데이터베이스 삭제, 테이블 자체를 삭제
   · TRUNCATE : 데이터베이스 저장 공간 삭제, 
                     테이블에 저장된 모든 내용을 삭제(테이블은 남아있음)
   · RENAME : 데이터베이스 객체이름 변경, 테이블 이름 변경

 - TCL(Transaction Control Language, 트랙잭션 처리어)
        ※ Transaction : 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위
   · COMMIT : 트랜잭션의 정상적인 종료처리, 변경된 내용을 영구 저장
   · ROLLBACK : 트랜잭션 취소, 변경되기 이전 상태로 되돌림
   · SAVEPOINT : 트랜잭션 내에 세이브포인트 설정

 - DCL(Data Control Language, 데이터 제어어)
   · GRANT : 데이터베이스에 대한 일련의 권한 부여
   · REVOKE : 데이터베이스에 대한 일련의 권한 취소

사용자 계정 만들기
 - CREATE USER 사용자ID IDENTIFIED BY 사용자PW;

역할 부여하기
 - GRANT 키워드를 사용
 - CONNECT : 접속할 수 있는 권한을 줌
 - RESOURCE : DDL 권한을 줌
 - 사용자 계정 만들기와 역할 부여 권한은 system에게만 있다.

데이터 타입
 - CHAR(size)
   · size 크기의 고정 길이 문자 데이터 타입
     크기를 10으로 지정하고 지정된 길이보다 짧은 데이터가 입력되면
     남은 칸은 공백으로 채워짐
   · 최대타입 : 2000바이트
   · 최소타입 : 1바이트

 - VARCHAR2(size)
   · size 크기의 가변 길이 문자 데이터 타입
     크기를 50으로 줘도 저장되는 데이터의 길이가 6이면
     길이가 6만 할당된다.
   · 최대타입 : 4000바이트
   · 최소타입 : 1바이트
   · 한글은 2바이트

 ※ VARCHAR와 VARCHAR2는 동의어
        VARCHAR는 나중에 다른 데이터 타입으로 바뀔 수 있기 때문에
        왠만하면 VARCHAR2를 사용

 - NVARCHAR2(size)
   · 국가별 문자 집합에 따른 size 크기의 
   · 문자 또는 바이트의 가변 길이 문자 데이터 타입
     크기를 50으로 줘도 저장되는 데이터의 길이가 6이면
     길이가 6만 할당된다.
   · 최대크기 : 4000바이트
   · 최소크기 : 1바이트

 - NUMBER(p,s)
   · p칸의 소수점 s자리
     ex) number(8,2) : 000000.00
          123456.789가 들어오면 반올림되서 123456.79가 들어감
          정수가 넘치면 늘어남
   · p : 1 ~ 38
   · s : -84 ~ 127
   · 매개변수가 없으면 가변 길이가 된다.

 - DATE
   · 날짜 형식을 저장하기 위한 데이터 타입
   · 컬럼을 만들고 자료를 삽입할 때 
     to_date('xxxx-xx-xx','yyyy-MM-dd') 이런 식으로 사용

 - ROWID
   · 데이터베이스에서 데이터마다의 주소를 의미
   · 각각의 데이터를 구분할 수 있는 유일한 ID
   · 구조
     - 오브젝트 번호(32bit,6자리) : 해당 데이터가 속하는 오브젝트 번호
		                   오브젝트별로 유일값을 가지고 있다.
     - 상대 파일 번호(10bit,3자리) : 테이블스페이스는 여러 개의 DATAFILE을 생성할 수 있다.
			        10bit이기 때문에 테이블스페이스당 1023개의 DATAFILE을 추가 가능
			        DATAFILE은 해당 테이블스페이스의 상대 파일 번호를 의미
			        각 데이터별로 유일한 값을 가짐
     - 블록 번호(22bit,6자리) : 파일 안에 어느 블록인지 의미
     - 데이터 번호(16bit,3자리) : 오브젝트 번호, 파일번호, 블록 번호가 같으면 데이터 번호는 
			    블록별로 데이터가 저장되어 있는 순서를 의미
     = 총 80bit(18자리) = 10byte

 - BLOB
   · 대용량의 바이너리 데이터를 저장하기 위한 데이터 타입
   · 최대크기 : 4GB
   · 이미지를 쓸 때 사용

 - CLOB
   · 대용량의 텍스트 데이터를 저장하기 위한 데이터 타입
   · 최대크기 : 4GB
             
 - BFILE
   · 대용량의 바이너리 데이터를 파일 형태로 저장하기 위한 데이터 타입
   · 최대크기 : 4GB

 - TIMESTAMP(n)
   · DATE 데이터 타입의 확장된 형태
   · n은 milli second 자리수로 최대 9자리까지 표현 가능

 - INTERVAL YEAR TO MONTH
   · 년과 월을 이용하여 기간을 저장
 
 - INTERVAL DAY TO SECOND
   · 일, 시, 분, 초를 이용하여 기간을 저장
   · 두 날짜값의 정확한 차이를 표현하는데 유용

SELETE문
 - SQL의 가장 기본이 되는 문장
 - 테이블에 있는 자료를 검색할 때나, 함수를 써서 데이터를 보여줄 때 사용

 - SELECT 컬럼명 FROM 테이블명;이 기본 구조
    [ ]는 생략 가능하다는 의미,
    { , , }는 안에 있는 것 중 하나를 쓰면 된다는 의미
   · SELECT * FROM 테이블명 : 테이블에 있는 모든 레코드 출력, * = ALL
     만약 부분만 필요하면 SELECT 컬럼명1, 컬럼명2 FROM 테이블명;

 - DISTINCT : 중복 제거
    ex) SELECT DISTINCT job FROM emp;
         emp 테이블의 job행에서 중복을 제거한 결과를 보여줌

 - 연산이 필요한 경우
    ex) SELECT sal, sal*0.03 FROM emp;
         sal행과 sal행*0.03의 결과를 보여줌

 - 컬럼에 들어있는 값이 NULL인 경우 연산이 불가능하기 때문에
    NVL함수를 사용
    ex) SELECT comm, sal*12+comm, NVL(comm,0),sal*12+NVL(comm,0) FROM emp;
         comm의 값이 NULL이면 0을 넣어서 계산해라

 - 컬럼에 별칭 부여하기
   · as 뒤에 별칭을 쓰거나 그냥 별칭만 쓴다.
   · " "로 별칭을 부여한다.
   ex) SELECT DISTINCT job [as] 직위 FROM emp;
        SELECT DISTINCT job "직위" FROM emp;

 - Concatenation 연산자
   · 여러 개의 컬럼을 연결할 때 사용
     ||를 컬럼과 문자열 사이에 기술하여 하나로 연결
     ex) SELECT ename || '의 직급은 '|| job || '입니다.' 직급 from emp;

WHERE(조건절)
 - 원하는 row만 얻으려면 로우를 제한하는 조건을 제시
 - 비교 연산자
   · = : 같다
   · > : 크다
   · < : 작다
   · >= : 크거나 같다
   · <= : 작거나 같다
   · <>,!=,^= : 다르다
   · 날짜의 경우 이 전이면 작은 것, 이 후면 큰 것

 - 논리 연산자
   · AND : 두 조건 모두 참인 것만 검색
   · OR : 두 조건 중 하나만 참이어도 검색
   · NOT : 두 조건 다 거짓인 것만 검색

 - BETWEEN AND 연산자
   · BETWEEN a AND b : a와 b 사이
   · 특정 범위 내에 속하는 데이터인지 알아본다.
     ex) SELECT * FROM emp where sal between 400 and 500;
          SELECT * FROM emp where sal >= 400 and sal <= 500;과 같다.

 - IN 연산자
   · 특정 필드의 값이 A이거나 B이거나 C 중 하나만 만족하더라도 출력
   · in() : ~안에
     ex) SELECT * FROM emp where comm in(80,100,200);
          SELECT * FROM emp where comm = 80 or comm = 100 or comm = 200;과 같다.

 - LIKE 연산자와 와일드카드
   · LIKE : 유사일치(비슷하게라도 일치하는 것)
   · LIKE 다음에는 pattern을 기술해야 하는데 %와 _ 와일드카드가 있다.
     - % : 문자가 없거나, 하나 이상의 어떤 문자가 와도 상관없음
     - _ : 하나의 문자가 어떤 값이 와도 상관없음.
     ※ 문자가 없어도 되는 경우 %, 꼭 1개는 있어야 하는 경우 _를 사용

 - NULL인 값을 찾기 위한 IS NULL
   · SELECT * FROM emp where comm is null;
     comm의 값이 null인 것 찾기
   · SELECT * FROM emp where comm is not null;
     comm의 값이 null이 아닌 것 찾기

 - 정렬을 위한 ORDER BY절
   · ORDER BY 컬럼 : 컬럼을 기준으로 정렬
   · asc : 오름차순, 생략 가능
   · desc : 내림차순
   · NULL의 경우 오름차순이면 가장 마지막에 출력
	         내림차순이면 가장 먼저 출력
   · 여러 가지 조건 제시
     ex) 입사일이 느린 순으로 출력하되 입사일이 같으면 이름순으로 출력
          SELECT * FROM emp order by hiredate desc, ename;

집합 연산자
 - UNION(합집합)
   · select * from group_star UNION select * from single_star; (중복 x)
   · select * from group_star UNION ALL select * from single_star; (중복 o)
   · ALL이 붙으면 중복된 데이터까지 포함
     UNION만 가지고 있다.

 - DIFFERENCE(차집합)
   · select * from group_star MINUS select * from single_star;

 - INTERSECT(교집합)
   · select * from group_star INTERSECT select * from single_star;
 ※ 테이블 집합 테이블 순서

Dual 테이블
 - 바로 산술 연산의 결과를 한 줄로 얻음
   · select * from dual; = X라는 결과가 나옴
   · select 24*60 from dual; = 1440

숫자 함수
 - 숫자 데이터를 처리하기 위한 함수
   · ABS : 절대값을 구함
     - select ABS(-10) from dual; = 10

   · COS : COSINE값을 반환

   · EXP : e(2.71828183 ··· )의 n승을 반환

   · FLOOR : 소수점 아래를 잘라버림
     - select FLOOR(34.5678) from dual; = 34

   · LOG : LOG 값을 반환

   · POWER : POWER(m,n), m의 n승을 반환

   · SIGN : SIGN(n) n<0이면 -1, n=0이면 0, n>0이면 1을 반환

   · SIN : SINE 값을 반환

   · TAN : TANGENT 값을 반환

   · ROUND : 특정 자리수에서 반올림
     - select round(3.83, 1) from dual; = 3.8
        소수점 한자리까지 표시
        소수점 2번째 자리를 반올림

   · TRUNC : 특정 자리수에서 잘라버림
     - select TRUNC(34.5678, 2) from dual; = 34.56
     - select TRUNC(34.5678, -1) from dual; = 30
     - select TRUNC(34.5678) from dual; = 34
   ※ ROUND와 TRUNC에서 2번째 매개값이 음수면 1의 자리, 10의 자리, ...
				      양수면 소수점 첫번째, 두번째, ...
				       0이면 소수점 전체를 잘라버림

   · MOD : 입력 받은 수를 나눈 나머지 값을 반환
     - select mod(10, 3) from dual; = 1
        10/3의 나머지
        자바의 %와 같다.

문자 처리 함수
 - 문자형의 값을 조작하여 변환된 문자 값을 반환하는 함수
 - 대 · 소문자간의 변환을 위한 함수와
    문자열을 정교하게 조작하는 함수로 나뉨

 - 대소문자 변환함수
   · UPPER : 전부 대문자
     - select UPPER('Welcome') from dual; = WELCOME
   · LOWER : 전부 소문자
     - select LOWER('wELcome') from dual; = welcome
   · INITCAP : 첫 글자만 대문자, 나머지는 소문자
     - select INITCAP('welcome') from dual; = Welcome

 - 문자 길이를 구하는 함수
   · LENGTH : 문자 길이를 반환(한글 1byte)
     - select LENGTH('Oracle') from dual; = 6
     - select LENGTH('오라클') from dual; = 3
   · LENGTHB : 문자 길이를 바이트로 반환(한글 2 혹은 3byte)
     - select LENGTHB('Oracle') from dual; = 6
     - select LENGTHB('오라클') from dual; = 9

 - 문자 조작 함수
   · CONCAT : 문자끼리 연결
     - select CONCAT('ab','cd') from dual; = 'abcd', 2개만 연결 가능

   · SUBSTR : 문자를 잘라서 추출(한글 1byte)
     - select SUBSTR('Welcome to Oracle', 2, 3) from dual; = 'elc'

   · SUBSTRB : 문자를 잘라서 추출(한글 2~3byte)
     - select SUBSTRB('가나다라마바사', 2, 5) from dual = 나
        2바이트부터 5바이트 읽기
        완벽하게 3바이트가 포함된 글자만 출력
        가는 2,3만 포함되고 1이 포함되지 않아서 출력이 안된 것
        나는 4,5,6이 포함되서 출력

   · INSTR : 특정 문자의 위치 값을 반환(한글 1byte)
     - select INSTR('데이터베이스', '이', 4, 1) from dual; = 5
       매개값은 대상, 찾을 글자, 시작 위치, 시작위치부터 몇번째에 있는 것

   · INSTRB : 특정 문자의 위치 값을 반환(한글 2~3byte)
     - select INSTRB('데이터베이스', '이', 4, 1) from dual; = 4
        4바이트부터 '이'가 있는 바이트의 시작 바이트 수를 리턴
        4바이트에서 시작해서 '이'가 4바이트에 있으니 4,5,6바이트 중 4바이트를 반환

   · LPAD, RPAD : 입력 받은 문자열과 기호를 정렬하여 특정 길이의 문자열로 반환
     - select LPAD('Oracle', 20, '#') from dual; = ##############Oracle
        자리를 20칸 마련하고 데이터를 오른쪽부터 채우고 남은 칸은 #으로 채움
        왼쪽에서 값이 들어오고 나머지는 기호로 채움
     - select RPAD('Oracle', 20, '#') from dual; = Oracle##############
        자리를 20칸 마련하고 데이터를 왼쪽부터 채우고 남은 칸은 #으로 채움
        오른쪽에서 값이 들어오고 나머지는 기호로 채움

 - 형변환 함수
   · 자료형을 변환시키고자 할 때 사용
   · TO_CHAR : 날짜형 or 숫자형을 문자형으로 변환
     - TO_CHAR(날짜 데이터, '출력형식')
     - 날짜 출력 형식
       · YYYY : 년도 표현(4자리)
       · YY :  년도 표현(2자리)
       · MM : 월을 숫자로 표현
       · MON : 월을 알파벳으로 표현
       · DAY : 요일 표현
       · DY : 요일을 약어로 표현
     ex) select sysdate, to_char(sysdate,'yyyy/MM/dd') from dual;
          sysdate : 컴퓨터의 현재 시간을 가져오는 것
     - 시간 출력 형식
       · AM or PM : 오전, 오후 시각 표시
       · HH or HH12 : 시간(1~12)
       · HH24 : 시간(0~23)
       · MI : 분 표현
       · SS : 초 표현
     ex) select sysdate, to_char(sysdate,'yyyy/MM/dd, AM HH:MI:SS') from dual;
     - 숫자형을 문자형으로 변환
       · 0 : 자릿수를 나타내며 자릿수가 맞지 않을 경우 0으로 채움
       · 9 : 자릿수를 나타내며 자릿수가 많지 않을 경우 공백
       · L : 각 지역별 통화 기호
       · . : 소수점
       · , : 천 단위 자리 구분
     ex) select to_char(123400, 'L999,999,999') from dual; = \123,400

   · TO_DATE : 문자형을 날짜형으로 변환
     - TO_DATE('문자', 'format')
     ex) select to_date(sysdate,'yyyy/MM/dd') from dual;
          sysdate 자리에 문자형으로 임의의 날짜를 지정할 수 있음

   · TO_NUMBER : 문자형을 숫자형으로 변환
     - select to_number('199999') from dual;
   ※ 단 문자형이 숫자로만 이루어져 있어야 TO_DATE나 TO_NUMBER로 변환 가능

 - 날짜 함수
   · DATE형에 사용하는 함수
   · 결과 값으로 날짜 또는 시간을 얻음
     - SYSDATE : 시스템에 저장된 현재 날짜를 반환

     - MONTHS_BETWEEN : 날짜와 날짜 사이의 개월 수를 구함
       · select ename, sysdate 오늘, to_char(hiredate, 'yyyy/mm/dd')
                                          , trunc(MONTHS_BETWEEN(sysdate, hiredate)) from emp;

     - ADD_MONTHS : 특정 개월 수를 더한 날짜를 구함
       · select ename, to_char(add_months(hiredate, 6), 'yyyy-mm-dd') from emp;
         hiredate에 6개월을 더한 값을 출력

     - NEXT_DAY : 해당 요일의 가장 가까운 날짜를 반환
       · select to_char(sysdate, 'yyyy/mm/dd'), to_char(NEXT_DAY(sysdate, 'MONDAY'),'yyyy/mm/dd') from dual;
         이렇게 사용하면 오류 발생
         현재 컴퓨터 시스템의 국가형식이 대한민국이라서 영어요일은 오류 발생
         한국 요일이나 숫자를 사용해야 한다(일=1, 월=2, ...) 
       · select to_char(sysdate, 'yyyy/mm/dd') 오늘,
                 to_char(next_day(sysdate,'월'),'yyyy/mm/dd') 월요일
                 from dual;
       · select to_char(sysdate, 'yyyy/mm/dd') 오늘,
                 to_char(next_day(sysdate,2),'yyyy/mm/dd') 월요일
                 from dual;

     - LAST_DAY : 각 월의 마지막 날짜를 반환
       · select ename, to_char(hiredate,'yyyy/mm/dd'), to_char(last_day(hiredate), 'yyyy/mm/dd') from emp;

     - ROUND : 인자로 받은 날짜를 특정 기준으로 반올림
       · ROUND(date, format)
       · 숫자 이외에 날짜에 대해서도 반올림 가능
         - CC, SCC : 4자리 연도의 끝 두 글자를 기준으로 반올림
         - SYYY, YYYY, YEAR, SYEAR, YYY, YY, Y : 년(7월 1일부터 반올림)
         - DDD, D, J : 일을 기준
         - HH, HH12, HH24 : 시를 기준
         - Q : 한 분기의 두 번째 달의 16일을 기준으로 반올림
         - MONTH, MON, MM, RM : 월(16일을 기준)
         - DAY, DY, D : 한 주가 시작되는 날짜
         - MI : 분을 기준   
       · select to_char(hiredate, 'yyyy/mm/dd') 입사일, to_char(round(hiredate, 'YEAR'),'yyyy/mm/dd') 입사일 from emp;

     - TRUNC : 인자로 받은 날짜를 특정 기준으로 버림
       · TRUNC(date, format)
       · select TO_CHAR(TRUNC(hiredate, 'MONTH'), 'yyyy/MM/dd') from emp;

NULL을 다른 값으로 변환하는 함수
 - NVL 함수는 NULL을 0 또는 다른 값으로 변환
   · NVL(expr1, expr2) = expr1이 null이면 expr2로 반환
   · NVL2(expr1, expr2, expr3) = expr1이 null이 아니면 expr2를 반환, null이면 expr3를 반환

 - NULLIF : 두 표현식을 비교하여 동일하면 null, 다르면 첫번째 값을 반환
   · NULLIF(expr1, expr2)
     동일하지 않으면 expr1 반환
     동일하면 null 반환
   · ex) select nullif('a','a'),nullif('a','b') from dual; = null, a


 - COALESCE 함수
   · null이 아닌 첫 번째 인수를 반환
   · null을 빼고 첫번째로 나오는 값
   · ex) select coalesce('a','b','c','d') from dual; = a
         select coalesce('a','b',null,'c','d') from dual; = a
         select coalesce('a','b','c',null,'d') from dual; = a

DECODE 함수
 - switch case 문과 같은 기능
   · select ename, deptno, decode(deptno, 10, '경리부',
                                                       20, '인사과',
                                                       30, '영업부',
                                                       40, '전산부',
                                                       deptno) from emp; 
  				       ↑어디에도 포함되지 않는 경우


조건에 따라 서로 다른 처리가 가능한 CASE
 - CASE는 다양한 비교 연산자를 이용하여 조건을 제시할 수 있으므로 
    범위를 지정할 수도 있음
 - if else-if else와 유사한 구조
   · case when 기준 = 값 then 출력할 결과
   · select ename, deptno, 
     case when deptno = 10 then '경리부'
            when deptno = 20 then '인사부'
            when deptno = 30 then '영업부'
            when deptno = 40 then '전산부'
            end as dname from emp;

그룹 함수
 - 단일행 함수는 값이 들어오면 들어온 갯수만큼 나감
    그룹 함수는 값이 들어오면 종합해서 1개만 나감
   · SUM : 그룹의 누적 합계를 반환
   · AVG : 그룹의 평균을 반환
   · COUNT : 그룹의 총 개수를 반환
     - null 값은 세지 않음
     - COUNT(*) : 테이블의 전체 로우(행) 수를 구함
   · MAX : 그룹의 최대값
   · MIN : 그룹의 최소값
   · STDDEV : 그룹의 표준편차
   · VARIANCE : 그룹의 분산을 반환

Group by절
 - 특정 컬럼을 기준으로 그룹 함수를 사용해야 할 경우
     어떤 컬럼 값을 기준으로 그룹 함수를 적용해 줄지를 결정할 때 사용
   · 부서별로 총합(부분합)
      select deptno, sum(sal) from emp group by deptno;
   · 직급별로 총합(부분합)
      select job, sum(sal) from emp group by job;
   · 부서별 직급이 사원인 사람들의 월급 총합
      select deptno, sum(sal) from emp where job='사원' group by deptno;
   · 김씨 성을 가진 사람들의 월급 평균
      select job, avg(sal) from emp where ename like '김%' group by job;
   · 입사일이 2000년부터 2003년 사이
      select job, avg(sal) from emp where substr(hiredate, 1, 2) in('00','01','02','03') group by job;
   · 부서번호, 최대값, 최소값을 구해서 최대값 오름차순으로 정렬
      select deptno, max(sal), min(sal) from emp group by deptno order by max(sal);

그룹 결과 제한 HAVING절
 - SELECT절에 조건을 사용하여 그룹의 결과를 제한할 때 사용
    (그냥 결과를 제한할 때는 WHERE절 사용)
   · 평균이 500 이상만 출력
      select deptno, avg(sal), max(sal), min(sal) from emp group by deptno having avg(sal) >= 500;

※ select deptno, avg(sal), max(sal), min(sal) from emp group by deptno having avg(sal) >= 500 order by deptno;
   순서가 정해져 있는것, 
   검색 1등 WHERE조건절 2등 그룹 3등 HAVING조건절 4등 정렬 5등


INSERT : 행 추가
	INSERT INTO 테이블명[(컬럼명1, 컬럼명2, ... )] values(값1, 값2, ...);
	NULL값 넣기 : 값으로 null을 주거나, 값으로 ''만 넣는다.
	날짜 입력은 직접 쓰거나 TO_DATE를 사용

UPDATE : 행 수정
	 UPDATE 테이블명 SET 수정될컬럼명 = 수정될값 WHERE 컬럼명 = 값
	 UPDATE는 WHERE절과 같이 사용
	     (WHERE를 사용하지 않으면 모든 행이 수정된다.)
	 연산도 가능하다
	     UPDATE 테이블명 SET 컬럼명 = 컬럼명 + 100;

DELETE : 행 삭제
	DELETE [FROM] 테이블명 WHERE 컬럼명 = 값;
	UPDATE와 마찬가지로 WHERE절과 같이 사용
	WHERE절의 조건이 2개인 경우
	    DELETE 테이블명 WHERE 컬럼명 = 값 and 컬럼명 = 값;
	WHERE절의 조건에서 값이 null인 경우를 찾을 때 in null 사용
	    DELETE 테이블명 WHERE 컬럼명 is null;

오라클은 트랜잭션을 기반으로 데이터의 일관성을 보장한다.
트랜잭션이란?
 - 데이터 처리에서 논리적으로 하나의 작업 단위를 의미
 - db시점에서는 커밋 롤백의 개념
 - jdbc에서는 자바에서 sql문을 하나하나 보낼 때마다 자동커밋이 되기 때문에
       자동커밋을 끄고 작업을 해서 마지막까지 정상 처리가 되면 수동 커밋을 한다.
       중간에 문제가 생기면 롤백으로 작업 이전으로 돌아감.

COMMIT : 모든 작업들을 정상적으로 처리하겠다고 확정하는 명령어

ROLLBACK : 마지막 커밋 지점으로 돌아감

데이터 무결성 제약조건
 - 테이블에 부적절한 자료가 입력되는 것을 방지하는 것
       테이블 생성시 각 컬럼에 대해 정의하는 여러가지 규칙
 1) NOT NULL : NULL을 허용하지 않음.
 2) UNIQUE : 중복을 허용하지 않음(유일한 값)
 3) PRIMARY KEY : NOT NULL + UNIQUE
 4) FOREIGN KEY : 참조되는 테이블의 컬럼에 같은 값이 존재하면 허용
		    기본키에 있는 데이터만 외래키가 있는 테이블에 입력 가능
		    외래키를 지정한 테이블에 값을 넣으려고 시도하면
		        기본키에 그 값이 있는지 확인하고 있으면 허용 없으면 에러
 5) CHECK : 저장 가능한 데이터 값의 범위나 조건을 지정하여 설정한 값만 허용

제약조건 확인하기
 - USER_CONSTRAINTS 데이터 딕셔너리로 내가 만든 제약조건의 정보를 조회
    · OWNER : 제약조건을 소유한 사용자명
    · CONSTRAINT_NAME : 제약조건 명
    · CONSTRAINT_TYPE : 제약조건 타입
	1) P : PRIMARY KEY
	2) R : FOREIGN KEY
	3) U : UNIQUE
	4) C : CHECK, NOT NULL
    · TABLE_NAME : 제약조건이 속한 테이블명
    · SEARCH_CONDITION : CHECK 조건일 경우 어떤 내용이 조건으로 사용되었는지?
    · R_CONSTRAINT_NAME : FOREIGN KEY인 경우 어떤 PRAMARY KEY를 참조했는지?
	ex) SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE
		FROM USER_CONSTRAINTS;
	     SELECT * FROM USER_CONSTRAINTS;

CONSTRAINT : 제약조건을 주는 키워드

칼럼 레벨 제약조건 설정하기
 - 칼럼 레벨로 제약조건 이름을 명시해서 제약조건 설정
       이 때 생긴 이름은 인덱스라고 부르며 검색할 때 검색키로 사용해서 검색 속도를 향상
        칼럼명 타입 CONSTRAINT 제약조건명 제약조건
 - 칼럼을 생성할 때 제약조건을 지정
       테이블 생성시 마지막에 쓰는건 테이블 레벨 제약조건
 - 따로 제약조건의 이름을 명시하지 않으면 오라클에서 자동으로 만들어준다.
 - 제약조건 이름 양식 
       테이블명_칼럼명_제약조건타입
 - NOT NULL은 칼럼 레벨 방식의 제약조건만 가능하다.

PRIMARY KEY : NOT NULL 제약조건과 UNIQUE 제약조건을 모두 갖고 있는 제약조건
		즉, 데이터들끼리의 유일성을 보장하는 칼럼에 설정
		테이블당 한개만 설정이 가능하다.
		단, 칼럼 두 개 이상을 하나로 묶어서 하나처럼 설정은 가능 = 복합키
		    이 경우 중복을 막을 때 두 컬럼이 모두 같은게 있으면 막는다.

FOREIGN KEY : 기본키에 존재하는 데이터만 외래키가 있는 테이블에 입력할 수 있다.
		부모테이블은 자식의 데이터나 테이블이 삭제된다고 영향을 받지 않는다.
		참조하는 데이터 칼럼과 데이터 타입이 "반드시" 일치해야 한다.
		참조할수 있는 컬럼은 기본키 or UNIQUE만 가능하다.
		외래키는 기본키

CASCADE : PARENT(기본키) 삭제 시 CHILD(외래키)도 같이 삭제(사용을 지양)
SET NULL : PARENT 삭제 시 CHILD의 해당 필드를 NULL로 UPDATE
SET DEFAULT : PARENT 삭제 시 CHILD의 해당 필드를 DEFAULT 값으로 UPDATE
RESTRICT : CHILD 테이블에 PK 값이 없는 경우만 PARENT 삭제
NO ACTION : 참조 무결성 제약조건을 위배하는 액션은 불가

COMPOSITE KEY : 여러 열을 조합하여 기본키 역할을 할 수 있게 만든 키(복합키)
	               하나의 열만으로 행을 식별하는 것이 불가능하여 여러 열 값을
		   함께 사용해야 각 행이 유일한 데이터로서 가치를 지닌다.
		   이 경우 외래키로 참조할 때 복합키에 조합된 열 중 하나를 UNIQUE로 만들어서 참조?

CHECK : 입력되는 값을 체크하여 설정된 값 이외의 값이 들어오면 
	  오류 메시지와 함께 명령이 수행되지 못하게 하는 것.
	  조건으로 데이터의 값의 범위나 특정 패턴의 숫자나 문자 값을 설정할 수 있다.
	  ex) 컬럼명 number CONSTRAINT 테이블명_컬럼명_이름 CHECK(컬럼명 BETWEEN 500 AND 5000)
	       컬럼명 varcher2 CONSTRAINT 테이블명_컬럼명_이름 CHECK(컬럼명 IN('M','m','F','f')

DEFAULT : 아무런 값을 입력하지 않았을 때 디폴트로 값이 입력된다.
	      NULL도 값이라서 NULL을 넣으면 디폴트 값이 아닌 NULL이 들어간다.
	      컬럼명 varcher2 DEFAULT '없음'

테이블 레벨 방식의 제약조건
 - 컬럼을 모두 정의하고 나서 테이블 정의를 마무리 짓기 전에
       따로 생성된 컬럼들에 대한 제약조건을 한꺼번에 지정하는 것
       [CONSTRAINT 테이블명_컬럼명_제약조건타입] 제약조건
	                  생략 가능

 - 복합키로 기본키를 지정할 경우
       2개 이상의 컬럼이 하나의 기본키를 구성하는 경우
       복합키 형태로 제약 조건을 지정할 경우 컬럼 레벨 형식으로는 불가능
       반드시 테이블 레벨 방식을 사용
       CONSTRAINT 인덱스 PRIMARY KEY(컬럼명1, 컬럼명2, ... )
 
 - ALTER TABLE로 제약조건을 추가할 때
       테이블의 정의가 완료되어서 이미 테이블의 구조가 결정된 후에
       나중에 테이블에 제약 조건을 추가하고자 할 때 테이블 레벨 방식을 사용
       (왠만하면 테이블을 정의할 때 제약조건을 정의하자.)

PRIMARY KEY로 만든 column명 조회하기
 - SELECT constraint_name, table_name, column_name FROM USER_CONS_COLUMNS;

SEQUENCE : 번호표(인덱스) 붙이는 담당자
	       레코드의 특정 컬럼에 대해 자동으로 인덱스를 부여할 수 있음
	       NEXTVAL을 사용하여 다음 인덱스로 넘어감
	       한 번 넘어간 인덱스는 이전 인덱스로 돌아올 수 없다.
	       중복 인덱스가 부여되지 않으므로 UNIQUE 성질을 지킬 수 있다.
	       - 생성
	           · CREATE SYQUENCE 시퀀스명;
	       - 사용
	           · 시퀀스명.NEXTVAL을 기본키로 지정된 컬럼에 넣는다.
	       - 삭제
	           · DROP SEQUENCE 시퀀스명;
	       - 현재 유저의 모든 시퀀스에 대한 정보 조회
	           · SELECT * FROM USER_SEQUENCES;
	       - 시퀀스 현재값 조회
	           · SELECT 시퀀스명.CURRVAL FROM DUAL;
		     DUAL 테이블이 아닌 사용하고 있는 테이블을 쓰면
		     값이 행의 갯수만큼 여러번 출력
		     DUAL 테이블 : 산술연산의 결과를 한줄로 얻기 위한 오라클 기본 제공 테이블
	       - 시퀀스 옵션
	           · START WITH n : n부터 시작
	           · INCREMENT BY n : n씩 증가(음수면 감소, DEFAULT 1)
	           · MAXVALUE n : 최대값을 n으로 지정
	           · NOMAXVALUE : 최대값 없음(무한대로 증가, 기본설정)
	           · MINVALUE n : 최소값을 n으로 지정
	           · NOMINVALUE : 최소값 없음(무한대로 감소, 기본설정)
	           · CYCLE : 최대값/최소값 도달시 순환(다시 최대값/최소값부터 시작)
	           · NOCYCLE : 순환하지 않음(도달하면 더 이상 NEXTVAL을 사용할 수 없음, 기본설정)
	           · CACHE : 미리 메모리에 생성 해두겠다, DEFAULT 20
	           · NOCACHE : 미리 메모리에 생성해두지 않겠다.
	           ※ ','로 구분하지 않고 그냥 띄워쓰기로 구분

제약조건 변경하기
 - 이미 존재하는 테이블에 제약조건을 추가, 삭제, 변경하는 경우
      ALTER TABLE문을 사용
 - 추가
   · ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 PRIMARY KEY(칼럼명);
 - 삭제
   · ALTER TABLE 테이블명 DROP PRIMARY KEY;
        기본키만 가능하다.
   · ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명;
 - NOT NULL은 MODIFY로 변경
   · 이미 NULL이 추가되어 있다고 생각해서 NOT NULL로 변경하기 때문에  
   · 추가 : ALTER TABLE 테이블명 MODIFY 칼럼명 CONSTRAINT 제약조건명 NOT NULL;
   · 삭제 : 삭제는 동일함
	 ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명;
 - UNIQUE 제약조건은 중복을 막아서 유일한 값이 되게 한다.
      단, NULL 값은 예외로 함

제약 조건의 활성화/비활성화
 - 업무를 수행하는 과정에서 제약조건 때문에 작업이 진행되지 못하는 경우
       제약조건을 삭제해 버리면 데이터 무결성을 보장받지 못함
       이런 경우 제약조건을 비활성화시킴으로서 제약조건 사용을 보류시킴

 - 제약조건 비활성화
   · 제약조건을 삭제하지 않고 비활성화하여 사용을 잠시 보류
      ex) 외래키가 참조하고 있는 기본키의 데이터를 삭제해야 할 경우
              외래키를 비활성화한 뒤 기본키를 삭제
	  ALTER TABLE 테이블명 DISABLE CONSTRAINT 제약조건명;

 - 제약조건 활성화
   · 사용을 잠시 보류해 놓은 제약조건을 깨움
      ex) ALTER TABLE 테이블명 ENABLE CONSTRAINT 제약조건명;

 - CASCADE 옵션
   · 부모테이블과 자식테이블 간의 참조 설정이 되어 있을 때
       부모테이블의 제약조건을 비활성화하면 이를 참조하고 있는
       자식테이블의 제약조건도 같이 비활성화
       ALTER TABLE 부모테이블 DISABLE PRIMARY KEY CASCADE;

   · 부모테이블의 제약조건을 삭제하면 이를 참조하고 있는
       자식테이블의 제약조건도 같이 삭제
       (그래서 사용을 지양함)

   · 강제로 참조관계를 끊고 부모 테이블을 삭제
        DROP TABLE 부모테이블명 CASCADE CONSTRAINTS;

   · 강제로 참조관계를 끊기
        ALTER TABLE 테이블명 DROP 제약조건 CASCADE;

외래키를 만들면서 옵션을 부여
 - CASCADE
   · ALTER TABLE 부모테이블명 DISABLE CONSTRAINT 제약조건명 CASCADE;
        기본키가 disable되면 외래키도 disable된다.
        다시 활성화하는 경우 기본키와 외래키 각각 활성화 한다
        ALTER TABLE 부모테이블명 ENABLE CONSTRAINT 제약조건명;
        ALTER TABLE 자식테이블명 ENABLE CONSTRAINT 제약조건명;
        기본키부터 활성화하고 외래키를 활성화하기

   · 부모테이블의 데이터를 지우면 그걸 참조하는 자식테이블의 데이터도 지워지는 것
        ALTER TABLE 자식테이블명 ADD CONSTRAINT 제약조건명 FOREIGN KEY(칼럼명)
	REFERENCES 부모테이블(칼럼명) ON DELETE CASCADE;
	(데이터 손실 우려가 있어서 사용을 지양한다.)

 - SET NULL
   · 부모테이블의 데이터를 지우면 그걸 참조하는 자식테이블의 데이터는 NULL이 되는 것
        ALTER TABLE 자식테이블명 ADD CONSTRAINT 제약조건명 FOREIGN KEY(칼럼명)
	REFERENCES 부모테이블(칼럼명) ON DELETE SET NULL;

자동으로 시스템이 부여한 제약조건명 얻기
 - SELECT * FROM USER_CON_COLUMNS WHERE TABLE_NAME = '테이블명(대문자로)';
   = CONSTRAINT가 임의로 부여된 제약조건명

JOIN
 - 2개 이상의 참조 관계인 테이블에 흩어져 있는 데이터들을 합치는 작업
      부모테이블(기본키)과 자식테이블(외래키)로 나눔 
      보통 부모테이블과 자식테이블은 1:N 관계
      하지만 부모와 자식은 상대적이라서 자식테이블이 다른 테이블의 부모테이블이 될 수도 있음

 - 참조 관계가 아니어도 JOIN 할 수 있음

Cartesian Product
 - 곱집합

 - 모든 경우의 수를 만들어서 가져오는 것
      A테이블의 row x B테이블의 row

 - ANSI JOIN에서는 CROSS JOIN이라 부름

 - JOIN 중 WHERE 절의 조건이 잘못 되었거나 없을 경우 발생

 - 사용하는 이유
      1) 데이터를 복제해서 원본 테이블을 반복해서 읽는 것을 피하기 위해 
      2) 실수로 JOIN 조건 컬럼 중 일부를 빼먹는 경우 발생
      3) 테스트를 위해 댜랑의 데이터가 필요할 때 이용
      단, 의도하지 않은 Cartesian Product는 데이터에 부하가 걸릴 수 있어서(너무 많아서)
          위험하므로 JOIN 조건절에 반드시 해당 테이블을 사용하는 조건들이 있는지 확인

테이블에 별칭(Alias) 붙이기
 - SELECT * FROM A테이블명 a, B테이블명 b WHERE a.칼럼명 = b.칼럼명;
      FROM에서 테이블명을 적고 별칭을 적어주면
      그 때부터 테이블명 대신 별칭으로 사용
      단, 원래 테이블명을 사용하면 오류 발생

모호성
 - 두 개의 테이블이 같은 이름의 칼럼을 가지고 있는 경우
       어느 테이블의 칼럼인지 알 수 없는 모호성을 가지기 때문에
       별칭이나 테이블명을 칼럼명 앞에 명시하여 모호성을 제거

ANSI JOIN
 - 국제 표준 SQL 방식
      DB 종류에 상관없이 먹히는 JOIN

 - INNER JOIN
   · ON : WHERE 대신 사용
   · USING : JOIN하는 두 테이블의 칼럼명이 같을 경우 사용
	      단, USING 사용시 SELECT절에 칼럼명 앞에 별칭을 붙이면 오류 발생

 - OUTER JOIN
   · LEFT / RIGHT / FULL

INNER JOIN(ANSI)
 - 관계가 있는 데이터끼리만 합침

 - 조건절에서 '=' 연산자만 사용

 - 구조 : SELECT * FROM A테이블명 [INNER] JOIN B테이블명 
	    ON A.칼럼명 = B.칼럼명;

 - JOIN 조건에서 값이 일치하는 데이터만 JOIN
                            일치하지 않은 데이터는 누락

 - 사용 예시
   · 테이블 3개를 JOIN
        SELECT * FROM A테이블 a JOIN B테이블 b ON a.칼럼명 = b.칼럼명
			      JOIN C테이블 c ON a칼럼명 = c.칼럼명;
   · 조건이 2개 이상인 경우
        SELECT * FROM A테이블 a JOIN B테이블 b 
	ON a.칼럼명 = 100 AND a.칼럼명 = b.칼럼명;

 - EQUI JOIN(ORACLE)
   · 가장 많이 사용되는 조인
   · SELECT * FROM A테이블명, B테이블명 
	WHERE A.칼럼명 = B.칼럼명;

 - NON-EQUI JOIN(ORACLE)
   · 사용 빈도가 매우 낮음
   · '='을 제외한 연산자를 사용
         BETWEEN AND, IS NULL, IS NOT NULL, IN, NOT IN
         >, >=, <, <=, <>

OUTER JOIN(ANSI)
 - OUTER : 공통으로 가지고 있지 않은 데이터

 - INNER JOIN과 반대 개념
      기준이 되는 테이블의 OUTER 데이터까지 모두 출력
      OUTER에는 NULL이 들어감

 - 사용 예시
   · 작가와 책 이름을 JOIN 할 때 책을 출간하지 않은 작가도 출력하는 경우
   · 지도교수가 결정되지 않은 학생의 이름이나
     담당학생이 결정되지 않은 교수의 이름까지 출력하는 경우

 - 장단점
   · 장점 : 모든 데이터를 다 출력
   · 단점 : OUTER가 많으면 그만큼 NULL이 많아서
	    DB 성능에 아주 나쁜 영향을 줄 수 있으므로 신중해야 함

 - LEFT/RIGHT/FULL OUTER JOIN
   · LEFT : 왼쪽의 테이블을 기준으로 공통인 데이터를 JOIN
	    단, 왼쪽의 OUTER도 NULL을 넣어서 출력
   · RIGHT : LEFT와 반대되는 개념
   ※ LEFT와 RIGHT를 같이 사용하면 가독성이 떨어지고 헷갈리기 때문에
         보통은 LEFT로 통일해서 사용함
   · FULL : 양쪽의 모든 데이터를 출력
	     OUTER에는 NULL을 넣어서 출력

 - SELECT * FROM A테이블 a (LEFT/RIGHT/FULL) OUTER JOIN B테이블 b
       ON a.칼럼명 = b.칼럼명;

 - Oracle의 경우 (+)를 사용
      기준이 되는 테이블 반대쪽에 (+)를 사용
      (+)를 빼먹으면 INNER JOIN이 된다.
      SELECT * FROM A테이블 a, B테이블 b WHERE a.칼럼명 = b.칼럼명(+);

SELF JOIN
 - 하나의 테이블로 JOIN
      JOIN의 대상이 나와 또 다른 나
 
 - 모호성을 제거하기 위해 테이블 하나에 서로 다른 별칭을 반드시 명시해야 함
      SELECT * FROM A테이블 a JOIN A테이블 A ON a.칼럼명 = A.칼럼명;

SELECT 쿼리 수행 순서
 - SELECT ⑤
    FROM ①
    WHERE ②
    GROUP BY ③
    HAVING ④
    ORDER BY ⑥

 ① FROM : 적혀있는 테이블들이 존재하는지 확인
	      권한이 있는지 확인, 권한이 없을 경우 DB가 Semantic Error를 발생

 ② WHERE : 어떤 조건들이 있는지 확인하고
	       테이블에서 조건에 맞는 로우들을 가지고 옴

 ③ GROUP BY : 가지고 온 로우들을 어떤 방식으로 GROUP BY 할 것인지 확인

 ④ HAVING : GROUP BY 한것 중에서 버려야할 데이터들이 있는지 확인

 ⑤ SELECT : 내가 가져온 로우 중 어떤 컬럼들을 출력해야 하는지 확인
                   일단 다 가져오고 난 다음에 SELECT절을 확인하기 때문에
	       SELECT * FROM과 SELECT에서 컬럼 1개만 가져온거랑
	       사실상 드는 IO비용은 같다.
	       단, SELECT절에 있는 컬럼들이 모두 인덱스에 담겨져 있다면 다른 문제

 ⑥ ORDER BY : 사용할 로우들과 필요한 컬럼들까지 다 가지고 왔을 때 정렬
	           SELECT절에서 컬럼에 별칭(Alias)을 지정해 놨을 경우

 ※ 이전 순서에서 Alias를 지정하면 이후 순서부터는 Alias를 사용할 수 있다.

 Semantic Error : SELECE 권한이 없는데 SELECT문을 사용하거나
	          UPDATE 권한이 없는데 UPDATE문을 사용하는 경우
 Syntax Error : 오타를 치거나, 쉼표가 있어야 하는데 쉼표가 없는 경우
	    
서브쿼리(부조회)
 - 쿼리 안에 있는 또 다른 쿼리
      밖에 있는 쿼리를 메인 쿼리,
      안에 있는 쿼리를 서브 쿼리라고 함

 - ( )안에 작성하면 ( )안에 있는 식부터 처리한다.

 - DML문 모두에서 사용할 수 있음

 - Nesting : 서브쿼리 안에 서브쿼리가 들어가는 것
	      메모리가 허용하는 한 무제한으로 중첩 가능
 
 - 서브쿼리에서 SELECT 하지 않은 컬럼은 메인쿼리에서 사용할 수 없음

 - 서브쿼리의 결과를 가지고 메인쿼리를 실행해서 결과를 얻음

 - 서브쿼리를 쓰면 무조건 성능에 안좋다?
      서브쿼리로 짜든, JOIN으로 풀어서 짜든 
      어떤 것이 유리한지 옵티마이저가 알아서 판단해서 
      실행 계획을 작성하기 때문에 성능과는 무관하다.

 - 서브쿼리를 반드시 쓰면 안되는 경우
      하나의 테이블을 메인쿼리와 서브쿼리에서 여러번 쓰는 경우
      성능이 굉장히 떨어짐
      
WHERE절에 사용하는 중첩 서브쿼리
 - 단일 행 서브쿼리
   · ( ) 결과가 오직 하나의 행을 반환 
   · 메인쿼리의 WHERE절에서는 단일 행 비교 연산자를 사용해야 함
        ※ 단일 행 비교 연산자 : =, >, >=, <, <=, <>

 - 다중 행 서브쿼리
   · ( ) 결과가 여러 개의 행으로 반환
   · 반드시 다중 행 연산자와 함께 사용해야 함
        ※ 다중 행 연산자 : IN, ANY, SOME, ALL, EXISTS
	IN : 서브쿼리 결과와 같은 값을 찾음
	ANY(SOME)
	 - 만족하는 값이 하나만 있으면 된다.(OR)
                 · 1000 > ANY (500, 1000, 2000)
	       1000 > 500 OR 1000 > 1000 OR 1000 > 2000과 동일
	           즉, 나올수 있는 모든 조건에 OR 연산을 수행한 것과 동일
	       ANY 값에 1000보다 작은 500이 있으므로 TRUE
                 · = ANY(SOME) : 서브쿼리 결과 중에서 하나라도 만족하는 값이 있으면 리턴(IN과 동일)
                 · > ANY(SOME) : 서브쿼리 결과 중에서 최대값을 반환
                 · < ANY(SOME) : 서브쿼리 결과 중에서 최대값을 반환

	ALL
             - 모든 값을 만족해야 한다.(AND)
                 · 1000 > ALL (500, 1000, 2000)
	       1000 > 500 AND 1000 > 1000 AND 1000 > 2000과 동일
	          즉, 나올 수 있는 모든 조건에 AND 연산을 수행한 것과 동일
	          1000이 ALL의 모든 값보다 작아야하므로 FALSE
                 · > ALL : 서브쿼리 결과 중에서 최대값을 반환
                 · < ALL : 서브쿼리 결과 중에서 최소값을 반환
	EXISTS : 서브쿼리의 값이 있을 경우 메인쿼리를 수행
	NOT EXISTS : 서브쿼리의 값이 없을 경우 메인쿼리를 수행

 - 서브쿼리로 테이블 생성하기
   · 제약조건은 복제되지 않음
   · 이미 존재하는 테이블과 동일한 구조와 내용을 갖는 새로운 테이블 생성
	CREATE TABLE 복제테이블명 AS SELECT * FROM 원본테이블명;
   · 이미 존재하는 테이블과 동일한 구조와 필요한 컬럼만 갖는 새로운 테이블 생성
	CREATE TABLE 복제테이블명 AS SELECT 필요한컬럼명 FROM 원본테이블명;
   · 조건에 일치하는 내용만 갖는 새로운 테이블 생성
	CREATE TABLE 복제테이블명 AS SELECT * 원본테이블명 WHERE 조건;
	    조건을 1=0으로 주면 구조만 동일한 빈 테이블이 생성

 - 서브쿼리로 데이터 삽입하기
   · 테이블 내용을 복사할 때 구조가 같은데 컬럼명이 다르면 삽입이 가능함

   · 구조 순서가 다르거나 갯수가 다르고 같은 타입의 컬럼이 있을 경우
         컬럼을 명시해주면 복사가 가능하다.
         INSERT INTO dept06(deptno, dname1, loc1) SELECT * FROM dept;
         INSERT INTO dept06 SELECT deptno, dname1, loc1 FROM dept; --위와 같음

 - 서브쿼리로 데이터 변경하기
   · UPDATE dept03 
         SET loc = (SELECT loc FROM dept03 WHERE deptno=40) 
	  WHERE deptno = 20;

 - 서브쿼리로 데이터 삭제하기
       DELETE emp02 
	WHERE deptno = (SELECT deptno FROM dept WHERE dname = '영업부');

View
 - 물리적인 테이블(Table)을 근거로 논리적인 가상 테이블(View)을 정의
         창문을 통해 보고싶은 부분(쿼리문)을 View로 만드는 것
 - DB의 SELECT문을 저장한 OBJECT
 - 쿼리문에서 테이블처럼 사용
 - 뷰를 사용하는 이유
        1) 긴 쿼리문이나 자주 사용하는 쿼리문을 View로 정의하면 접근을 단순화시킬 수 있음
                쿼리문을 View에 저장
        2) 보안에 유리함
                테이블의 일부 칼럼만 View로 만들어서 일부 데이터만 보여줄 수 있음
                    사용자에게 테이블을 보여주는 것이 아니라 View를 보여주는 것

 - View의 내부 구조
       desc user_views의 TEXT 칼럼에 View가 처리하는 쿼리문이 들어있음
 
 - View 정의하기
       테이블 복사와 같음
       CREATE VIEW 뷰이름 AS 쿼리문;

 - View 제거하기
       DROP VIEW 뷰이름;

 - View의 동작 순서
       1) 사용자가 쿼리문을 수행
              SELECT * FROM 뷰이름;
       2) View의 TEXT 칼럼안에 있는 자료인 SELECT문을 수행
       3) SELECT문을 통해 테이블의 데이터가 조회
       4) 조회에 의한 결과 수행
       5) 1번으로 결과를 리턴

 - View에 데이터 추가하기
       INSERT INTO 뷰이름 VALUES();
 
 - View에 있는 데이터 수정하기
       UPDATE 뷰이름 SET 바꿀내용 WHERE 조건

 - View에 있는 데이터 삭제하기
       DELETE 뷰이름 WHERE 조건
           조건을 주지 않으면 뷰의 모든 데이터 삭제

 ※ View에서 데이터를 추가, 수정, 삭제하면 물리적인 데이터에도 적용된다.
        View 생성시 근거로 사용된 테이블의 자료도 바뀌는 것

 - OP REPLACE
       View가 존재하지 않으면 생성하고 존재하면 수정함
       CREATE OR REPLACE VIEW 뷰이름 AS 쿼리문;

 - FORCE
       테이블이 없어도 View를 만드는 것
           단, 테이블이 생성되지 않으면 생성한 View도 사용할 수 없음
       거의 사용하지 않음
       CREATE OR REPLACE FORCE VIEW 뷰이름 AS 쿼리문;

 - NOFORCE
       테이블이 있어야 View를 만드는 것
       변경하지 않으면 Default(기본 설정)

 - WITH CHECK OPTION
       테이블 중 조건에 만족하는 ROW만으로 구성된 View를 생성
       WHERE절에 있는 칼럼의 값의 수정을 막음
       예시
           CREATE VIEW 뷰이름 
           AS SELECT * FROM 테이블명 
           WHERE deptno = 30 WITH CHECK OPTION;
               이 후에 deptno 수정시 오류 발생

 - WITH READ ONLY
       모든 칼럼을 읽기 전용으로 변경
           수정, 추가, 삭제가 불가능
       예시
           CREATE OR REPLACE VIEW 뷰이름
           AS SELECT * FROM 테이블명
           WHERE 조건 WITH READ ONLY;

INLINE VIEW 
 - SQL문 내부에 View를 정의하고 이를 테이블처럼 사용하는 것
 - FROM절에 쓰이는 서브 쿼리
 - 다른 쿼리에서 사용할 필요 없이 해당 SQL에서만 필요한 View일 경우
       View처럼 따로 Object를 생성하지 않고 SQL 안에 직접 기술해서 쓰는 일회성 View
 - SELECT * FROM (SELECT * FROM 테이블명) 별칭;
       별칭(Alias)는 경우에 따라 지정해주기

 - View로 View를 만들 수 있다.
       CREATE OR REPLACE VIEW 뷰이름 
       AS SELECT * FROM 테이블명
       ORDER BY 칼럼명;
       
       CREATE OR REPLACE VIEW 뷰이름2
       AS SELECT * FROM 뷰이름
       WHERE 조건;

ROWNUM
 - INSERT문을 이용하여 입력하면 자동으로 입력한 순서에 따라 1씩 증가하면서 값이 지정
 - 데이터가 입력된 시점에서 결정되는 ROWNUM 칼럼의 값은 바뀌지 않음
 - ROWID와 다르다.       
       ROWID는 ROW가 가진 고유의 값

CEIL
 - 값을 나눴을 때 소수점이 발생하면 【무조건 올려줌】
       SELECT CEIL(10/3) FROM DUAL;
           결과는 3.333…이지만 CEIL이라서 4가 나옴

ROLLUP
 - 그룹별 Sub Total의 개념
 - GROUP BY를 한 결과를 가지고 롤업하면 GROUP BY를 한 애들의 총합을 구할 수 있음
       여러 칼럼을 ROLLUP할 경우 ROLLUP(칼럼명1, 칼럼명2)를 하게 되면
       GROUP BY 칼럼명1, 칼럼명2 + GROUP BY 칼럼명1 + 총합계
           어떤 칼럼이 앞에 오느냐에 따라 결과가 달라짐
       칼럼이 3개일 경우
       GROUP BY 칼럼명1, 칼럼명2, 칼럼명3 + GROUP BY 칼럼명1, 칼럼명2
       + GROUP BY 칼럼명1 + 총합계
       만약 GROUP BY ROLLUP으로 여러개를 묶었지만 필요 없는 총계들이 생길 경우
           필요없는 총계들끼리 묶어준다.

실행 내역 확인하기
 - SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(null, null, 'ALLSTATS LAST'));

ROLLUP
 - GROUP BY의 확장된 형태
       GROUP BY별 Sub Total의 개념 
 - 복잡한 SQL문을 짧게 만들고 해당 데이터들을 반복적으로 읽는 것을 최소화해서 속도가 빠름
 - 계층적 분류를 포함하고 있는 데이터의 집계에 적합
 - 어떤 칼럼이 먼저 오느냐에 따라 결과가 달라진다.
 - 지정된 칼럼들은 소계의 기준이 된다.
       칼럼들의 수를 n이라고 하면 n+1의 소계 그룹이 생성
       예시
           칼럼이 3개일 경우
           ROLLUP(칼럼1,칼럼2,칼럼3) 
           + ROLLUP(칼럼1,칼럼2) 
           + ROLLUP(칼럼1) 
           + 총합계

 - GROUP BY의 원리
       ROLLUP의 인자로 들어온 칼럼을 오른쪽부터 하나씩 빼면서 GROUP을 만든다.
       ( )의 의미는 GROUP이 없는 즉, 전체에 대한 결과를 출력한다는 뜻
       괄호로 묶여져 있는 칼럼은 하나로 본다는 뜻
       ROLLUP 이전에 일반 칼럼과 GROUP BY 한다면, 일반 칼럼은 끝까지 남는다.
           GROUP BY ROLLUP(A, B, C)
               1) A B C
               2) A B
               3) A
               4) ( )
           GROUP BY ROLLUP(A, (B, C))
               1) A (B C)
               2) A
               3) ( )
           GROUP BY A, ROLLUP((B, C))
               1) A (B C)
               2) A  

 - 참고글 : https://myjamong.tistory.com/191

CUBE
 - 각 그룹의 모든 경우의 수에 대한 소계와 총계를 구함
 - ROLLUP과 CUBE의 차이점은
       ROLLUP
           GROUP BY ROLLUP(칼럼명A, 칼럼명B)
               대상 데이터에 대해, 칼럼A와 B에 따라
               1) 칼럼(A, B)에 따른 소계를 자동 계산하여 결과 테이블 중간에 출력
               2) 전체 총계를 자동 계산하여 결과 테이블 가장 아래에 출력
       CUBE
           GROUP BY CUBE(칼럼명A, 칼럼명B)
               대상 데이터에 대해, 칼럼A와 B에 따라
               1) 칼럼(A, B)에 따른 소계를 자동 계산하여 결과테이블 중간에 출력
               2) 전체 총계를 자동 계산하여 결과 테이블의 가장 윗행에 출력
               3) 칼럼 A별 소계, 칼럼 B별 소계를 자동 계산하여 결과 테이블 가장 윗행에 출력

       ※ ROLLUP은 A의 소계만 나오고 CUBE는 A와 B의 소계가 나온다.

SEQUENCE
 - 일련번호
       중복되면 안되고 계속해서 번호가 증가
 - 테이블 내의 유일한 숫자를 자동으로 생성하는 자동 번호 발생기
       기본키로 사용하면 사용자의 부담이 줄어든다.
           ex) CREATE TABLE 테이블명(
	        test number(3));
	        INSERT INTO 테이블명 VALUES(시퀀스명.NEXTVAL);

 - 시퀀스 생성하기
       CREATE SEQUENCE 시퀀스명
           [START WITH n] : 시작하는 숫자,
		          DEFAULT는 1
           [INCREMENT BY n] : 증가하는 숫자,
			 DEFAULT는 1
           [MAXVALUE n | NOMAXVALUE] : 최대 숫자
				     DEFAULT는 NOMAXVALUE
           [MINVALUE n | NOMINVALUE] : 최소 숫자
				   DEFAULT는 NOMINVALUE
           [CYCLE | NOCYCLE] : 최대가 되면 최소로,
			 DEFAULT는 NOCYCLE
           [CACHE n | NOCACHE] : 메모리에 시퀀스 값을 미리 할당하는지 안하는지,
			      시퀀스로 번호를 생성할 때마다 번호를 계산해서 뽑게 되면
			          시간이 많이 걸리기 때문에 
                                              CACHE 20하면 번호 20개를 미리 뽑아놓으라는 의미
           ※ ','로 구분하지 않음

 - 시퀀스 삭제하기
       DROP SEQUENCE 시퀀스명;

 - 시퀀스 수정하기
       ALTER SEQUENCE 시퀀스명 
           수정할 내용
               ex) INCREMENT BY 20
                    CYCLE
       단, 시작 위치는 수정할 수 없다.
       INCREMENT BY를 수정하면 시작 위치가 1로 바뀐다.

 - NEXTVAL
       현재 시퀀스의 다음 값 구하기
       다음 포인터가 어디를 가르키는지?
       주로 INSERT문에 많이 사용된다.

 - CURRVAL
       현재 시퀀스의 값 구하기
       현재 포인터가 어디를 가르키는지?
       시퀀스를 생성하고 NEXTVAL을 하지 않고 CURRVAL을 하면 
           시작 위치에서 한 번도 이동하지 않아서 포인터 위치를 알 수 없으므로 오류 발생

인덱스
 - SQL 명령문의 처리 속도를 향상시키기 위해 칼럼에 대해 생성하는 오라클 객체
 - 오라클에서 인덱스의 내부 구조는 보통 B(2진) 트리 형식으로 구성
 - 인덱스가 생성되면 테이블과 매핑된 또 다른 테이블이 하나 생성된다.
       인덱스에서 먼저 데이터들을 찾은 다음 
       매핑된 테이블로 가서 나머지 데이터들을 꺼내오는 방식
 - 장점
       정렬, 검색 속도가 빨라짐
       시스템에 걸리는 부하를 줄여서 시스템 전체 성능을 향상
 - 단점
       인덱스를 위한 추가적인 공간이 필요
       인덱스를 생성하는데 시간이 걸림
       데이터 변경 작업이 자주 일어날 경우 오히려 성능이 저하된다.
                   (INSERT, UPDATE, DELETE)

 - 인덱스를 사용하면 효율적인 경우
       1) 테이블에 행의 수가 많은 경우
       2) WHERE절에 칼럼이 많이 사용되는 경우
       3) 검색 결과가 전체 데이터의 2~4%일 경우
       4) JOIN에 자주 사용되는 칼럼이나 NULL을 포함하는 칼럼이 많은 경우
       5) ORDER BY절에 자주 등장하는 칼럼을 인덱스로 지정
               인덱스는 정렬이 되서 저장되어 있기 때문에 
                따로 정렬을 할 필요가 없이 출력하면 된다.

 - 인덱스를 사용하면 비효율적인 경우
       1) 테이블에 행의 수가 적은 경우
       2) WHERE절에 해당 칼럼이 자주 사용되지 않는 경우
       3) 전체 결과가 전체 데이터의 10 ~ 15% 이상일 경우
       4) 테이블에 DML 작업이 많은 경우

 - 인덱스 생성하기 
       CREATE INDEX 인덱스명 ON 테이블명(칼럼명);
           칼럼을 기준으로 2진 트리를 만드는 것
 
 - 인덱스 제거하기
       DROP INDEX 인덱스명;

 - 인덱스 수정하기

 - 인덱스 정보 조회
       user_ind_columns

 - 인덱스의 종류
       고유 인덱스 : 유일키처럼 유일한 값을 갖는 칼럼에 대개 인덱스를 생성
		    데이터가 중복되는 칼럼은 고유 인덱스로 만들 수 없음
		    CREATE UNIQUE INDEX 인덱스명 ON 테이블명(칼럼명)

       비고유 인덱스 : 중복된 데이터를 갖는 칼럼에 대해 인덱스를 생성
		       CREATE INDEX 인덱스명 ON 테이블명(칼럼명)

       ※ 인덱스를 만든 칼럼으로 또 인덱스를 만들 순 없다.

       결합 인덱스 : 두개 이상의 칼럼으로 인덱스를 구성
		    CREATE INDEX 인덱스명 ON 테이블명(칼럼명1, 칼럼명2);
		        결합 인덱스이자 비 고유 인덱스
 		    이미 고유/비고유 인덱스로 만든 칼럼을 사용해서 결합 인덱스를 만들 수 있음
		        반대로 결합 인덱스로 만든 칼럼들로 고유/비고유 인덱스를 만들 수 있음
                            결합하는 칼럼의 순서가 중요
		         WHERE절에서 equal 조건으로 많이 쓰는 칼럼들이 앞으로 오는게 효율적
		         분별력이 높은 칼럼이 앞으로 오는게 효율적

       함수 기반 인덱스 : 검색 조건으로 WHERE sal = 300이 아니라
		           WHERE sal * 12 = 3600과 같이
		           WHERE절에 산술 표현 또는 함수를 사용하는 경우 인덱스를 타지 못함
                                       테이블명(칼럼명) 한거에 계산식을 하면 인덱스가 적용 안됨
		           SUBSTR도 마찬가지
		           이러한 경우 수식이나 함수를 적용하여 인덱스를 만들 수 있다.
		           CREATE INDEX 인덱스명 ON 테이블명(칼럼명 * 12);

 - 인덱스 수정하기
       ALTER INDEX 인덱스명 REBUILD;
           구조를 수정하는게 아님
           인덱스가 생성된 후 테이블에 새로운 행이 추가, 삭제, 변경되는 경우
           이진 트리를 다시 구성하는 것
           인덱스로 만든 칼럼의 데이터를 재구축
		           
사용자 관리
 - 관리자 계정
       sys : 모든 권한
       system : 계정에 대한 모든 권한

 - 현재 접속한 사용자 이름 
       SHOW USER;

 - 사용자 생성
       CREATE USER 유저ID IDENTIFIED BY 유저PW;
		           
SET TIMING ON
 - 작업 시간을 보는 것

Oracle 11g express edition 제한 사항
 - 시스템에서 하나의 CPU 코어만 사용
 - 최대 1GB RAM 사용
 - 11.2에 최대 4GB 데이터, 11GB의 데이터 저장
 - 분할 된 개체
 - 문자셋 변경
 - 구체화 된 뷰 질의 재 작성

권한의 역할과 종류
 - SYS : 모든 권한 관리자
             
 1) 사용자 만들기
        관리자(sys, system)에서 만들기

 2) 권한 부여
        권한있는 사용자가 권한 없는 사용자에게 GRANT로 권한 부여★ 
        GRANT 권한내용 TO 사용자명
        [WITH ADMIN OPTION]; 
            - 사용자명에 PUBLIC을 기술하면 모든 사용자에게 해당 시스템 권한이 부여된다.
            - WITH ADMIN OPTION : 부여받은 권한을 다른 사용자에게 부여할 수 있다
	- 관리자의 시스템 권한
	      CREATE USER : 사용자를 생성하는 권한
	      DROP USER : 사용자를 삭제하는 권한
	      DROP ANY TABLE : 임의의 테이블을 삭제할 수 있는 권한
	      QUERY REWRITE : 함수 기반 인덱스를 생성하는 권한
	      BACKUP ANY TABLE : 임의의 테이블을 백업할 수 있는 권한
                  CREATE SESSION : 접속할 권한
	
	- 사용자를 위한 시스템 권한
	      CREATE SESSION : DB에 접속할 수 있는 권한
	      CREATE TABLE : 사용자 스키마에서 테이블을 생성할 수 있는 권한
	      CREATE VIEW : 사용자 스키마에서 뷰를 생성할 수 있는 권한
	      CREATE SEQUENCE : 사용자 스키마에서 시퀀스를 생성할 수 있는 권한
	      CREATE PROCEDURE : 사용자 스키마에서 함수를 생성할 수 있는 권한

 ※ 테이블을 생성하거나 INSERT 할 때 데이터를 기록하려고 하는 
        테이블 스페이스에 권한이 없어서 오류 발생
            TableSpace : 테이블이 저장되는 공간
		         테이블의 데이터를 DELETE하고 Commit해도 
                                     TableSpace의 사용량은 변하지 않음
        ALTER USER 사용자명 QUOTA 50M ON USERS;
            사용자명에게 USERS 테이블스페이스를 50MB 사용할 수 있도록 권한 부여
        GRANT UNLIMITED TABLESPACE TO 사용자명;
            사용자명에게 모든 테이블스페이스에 대한 무제한 사용 권한 부여
        원래 하지 않아도 알아서 부여 되던건데 언제부턴가 바뀜.
        해당 유저에게 어떤 TableSpace에 어느정도 사용권한이 있는지 확인해보고 싶은 경우
            SELECT * FROM USER_TS_QUOTAS;
    
 3) 사용자로 접속하기
        방법1) WINDOWS> SQLPLUS USERNAME / PASSWORD;
        방법2) SQL> CONN USERNAME / PASSWORD;
            접속할 권한이 없으면 오류 발생

 4) 권한을 부여받은 사용자가 권한이 없은 사용자에게 권한 부여
        SYS에게 권한을 부여받을 때 
        GRANT 권한내용 TO 사용자명 WITH ADMIN OPTION;하면
        부여받은 권한을 다른 사용자에게 부여할 수 있다.


객체 권한
 - 특정 객체에 조작을 할 수 있는 권한
 - 객체의 소유자는 객체에 대한 모든 권한을 가진다.
       ALTER : TABLE, SEQUENCE
       DELETE : TABLE, VIEW
       EXECUTE : PROCEDURE
       INDEX : TABLE
       INSERT : TABLE, VIEW
       REFERENCES : TABLE
       SELECT : TABLE, VIEW, SEQUENCE
       UPDATE : TABLE, VIEW

 - GRANT 권한내용 ON 객체명 TO 사용자명
    [WITH GRANT OPTION] : 받은 객체 권한을 다른 사용자에게 부여할 수 있음
                                        2개를 받아서 1개만 넘겨줄 수도 있다.
       시스템 권한과 다른 점은 ON이 추가된다는 점
           ON에는 테이블 객체나 뷰 객체 등을 기술
           단, 권한을 부여 받은 사용자명은 자신의 객체가 아니기 때문에
               항상 객체를 사용할 때 객체명 앞에 객체를 소유한 사용자명을 명시한다.

 - 예시
       사용자1의 테이블을 사용자2가 검색(사용)을 하는 경우
           검색의 권한은 테이블을 가지고 있는 사용자1이 가지고 있다.
           GRANT SELECT ON 테이블명 TO 사용자2;
               SELECT * FROM 사용자1.테이블명;

 - Schema
       객체를 소유한 사용자명을 의미
       평소 스키마는 자신이 소유한 객체를 언급할 때 생략된다.
           SELECT * FROM 테이블명;
       하지만 다른 사용자가 소유한 객체를 언급할 때는 스키마를 명시한다.
           SELECT * FROM 스키마명.테이블명;
		       [사용자명]

권한 조회
    [롤 관련 데이터 사전]
        ROLE_SYS_PRIVS                         ROLE에 부여된 시스템 권한
        ROLE_TAB_PRIVS                         ROLE에 부여된 테이블 권한
        USER_ROLE_PRIVS                       현재 사용자가 ACCESS할 수 있는 ROLE
        USER_TAB_PRIVS_MADE               현재 사용자의 객체에 부여한 객체 권한
        USER_TAB_PRIVS_RECD               현재 사용자의 객체에 부여된 객체 권한
        USER_COL_PRIVS_MADE              현재 사용자 객체의 특정 컬럼에 부여한 객체 권한
        USER_COL_PRIVS_RECD               현재 사용자 객체의 특정 컬럼에 부여된 객체 권한

 - REVOKE
       사용자에게 부여한 객체 권한을 철회하는 명령어
           객체 권한을 준 곳에서 사용
               만약 sys, system에서 사용하려면 객체명 앞에 스키마명을 명시해준다.
       REVOKE 권한내용 ON 객체명 FROM 사용자명
       [CASCADE CONSTRAINTS]
           참조 객체 권한에서 사용 된 무결성 제한을 같이 삭제할 수 있음
       [WITH GRANT OPTION]; 
       사용자명에 PUBLIC을 주면 모든 사용자에게 준 권한을 철회하는 것
           주는건 TO 뺏는건 FROM
       WITH GRANT OPTION : 부여받은 객체 권한을 다른 사용자에게 부여할 수 있음
			     객체 권한을 부여한 사용자의 객체 권한을 철회하면,
		                 권한을 부여받은 사용자가 부여한 객체 권한 또한 
                                         같이 철회되는 종속철회가 발생

롤을 사용한 권한 부여
 - CONNECT 롤
       사용자가 데이터베이스에 접속 가능하도록 하기 위해 
           가장 기본적인 시스템 권한 8가지를 묶어 놓음
       ALTER SESSION, CREATE CLUSTER, CREATE DATABASE LINK, CREATE VIEW,
           CREATE SEQUENCE, CREATE SESSION, CREATE SYNONYM, CREATE TABLE

 - RESOURCE 롤
       사용자가 객체(테이블, 뷰, 인덱스)를 생성할 수 있도록 하기 위해
           시스템 권한을 묶어 놓음
       CREATE CLUSTER, CREATE PROCEDURE, CREATE SEQUENCE,
           CREATE TABLE, CREATE TRIGGER

 - DBA 롤
       사용자들이 소유한 데이터베이스 객체를 관리하고,
           사용자들이 작성하고 변경하고 제거할 수 있도록 하는 모든 권한을 가짐
           즉, 시스템 자원을 무제한적으로 사용하며,
               시스템 관리에 필요한 모든 권한을 부여할 수 있는 강력한 권한을 보유한 롤

 - 롤을 사용하여 권한 부여하기
       GRANT 역할명(롤), ... TO 사용자명;

 - 사용자에게 부여된 역할을 확인하기
       SELECT * FROM dict WHERE table_name LIKE '%ROLE%';

사용자 롤 정의
 - 사용자 롤 생성
       CREATE ROLE 롤이름;
 - 롤에 권한 부여
       GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW TO 사용자명
 - 사용자에게 롤 부여
       GRANT 롤이름 TO 사용자명;

 - 사용자에게 ROLE 회수하기
       REVOKE 롤이름 FROM 사용자명;
       롤을 부여했던 사용자에서 회수

 - ROLE 제거하기
       DROP ROLE 롤이름;
       롤을 만든 사용자에서 제거
       
 - ROLE의 장점
       여러 사용자들에게 동일한 역할을 부여하기 편리함.

 ※ ROLE : 여러가지 권한을 묶어놓은 곳

SYNONYM(동의어)
 - 다른 데이터베이스 객체에 대한 별명
 - 데이터베이스에서는 여러 사용자들이 테이블을 서로 공유하는데,
       다른 사용자의 테이블을 접근할 때 사용자명.테이블명으로 표현
       이를 동의어를 적용하여 간단하게 요약해서 기술할 수 있다.
 - 다른 계정에 있는 테이블을 가져다 쓰는 경우 보안상에 문제가 될 수 있어서 사용
 - 동의어는 지속적인 관리가 필요함
       동의어의 존재 유무를 모르는 사람이 동일한 이름의 테이블을 만드는 경우 오류 발생
       테이블을 생성한 사용자가 테이블을 지운경우 
           동의어를 통해 테이블을 이용하던 사용자들의 입장에서는 오류 발생

 - 동의어 생성하기
       CREATE [PUBLIC] SYNONYM 동의어명 FOR 사용자명.테이블명;
           PUBLIC을 붙이면 모든 사용자가 사용할 수 있는 공개 동의어가 된다.
           PUBLIC을 붙이지 않으면 PRIVATE 상태
               SYNONYM을 사용할 계정에서 생성
               보통 이름은 편의성을 위해서 테이블명과 동일하게 한다.★
                   ex) CREATE SYNONYM temp FOR test_table.temp;
      
 - 동의어 삭제하기
       DROP SYNONYM 동의어명;
       만약 공개 동의어일 경우 PUBLIC를 붙여준다.
           DROP PUBLIC SYNONYM 동의어명;

 - 현재 계정의 SYNONYM 조회
       SELECT * FROM user_synonyms

 - 전체 SYNONYM 조회
       SELECT * FROM all_synonyms
       
PL/SQL의 구조
 - Oracle's Procedural Language extension to SQL의 약자
 - SQL문장에서 변수 정의, 조건 처리(IF), 반복 처리(LOOP, WHILE, FOR) 등을 지원
       오라클 자체에 내장되어 있는 절차적 언어로서 SQL의 단점을 보완한다.
 - DECLARE(선언부, 옵션)
       PL/SQL에서 사용하는 모든 변수나 상수를 선언하는 부분
           DECLARE로 시작

 - BEGIN(실행부, 필수)
       절차적 형식으로 SQL 문을 실행할 수 있도록 절차적 언어의 요소인 
           제어문, 반복문, 함수 정의 등 로직을 기술할 수 있는 부분
           BEGIN으로 시작

 - EXCEPTION(예외처리부, 옵션)
       PL/SQL문이 실행되는 중에 에러가 발생할 수 있는데 이를 예외사항이라 함
           이러한 예외상황이 발생했을 때 이를 해결하기 위한 문장을 기술할 수 있는 부분
           EXCEPTION으로 시작

 - 작성 요령
       1) 블록 내에서 한 문장이 종료할 때마다 ';'을 사용
       2) END 뒤에 ';'을 사용하여 하나의 블록이 끝났다는 것을 명시
       3) 블록의 작성은 편집기를 통해 파일로 작성할 수 있고,
              프롬프트에서 바로 작성할 수도 있음
       4) SQL*PLUS 환경에서는 DECLARE나 BEGIN이라는 키워드로
              PL/SQL 블록이 시작하는 것을 알 수 있음
       5) 단일 행 주석은 --, 여러 행 주속은 /**/
       6) 쿼리문을 수행하기 위해서 /가 반드시 입력되어야 하며,
              PL/SQL 블록은 행에 /가 있으면 종결된 것으로 간주함

       ex) DECLARE -- 선언부
               vempno number(4); -- 스칼라 변수
               vename varchar2(10); -- 여기서 바로 초기값을 넣어도 된다
            BEGIN -- 실행부
                vempno := 1001; -- 값 넣기
                vename := '이지은';
                DBMS_OUTPUT.PUT_LINE(vempno||'     '||vename); -- syso와 비슷함, ||는 문자열과 문자열을 연결
                END; -- 끝
                / -- 실행
                
변수선언과 대입문
 - PL/SQL의 선언부(DECLARE)에서는 실행부(BEGIN)에서 사용할 변수를 선언
 - 형식
       변수명 [CONSTANT] 자료형 [NOT NULL] [:= | DEFAULT Expression];
           CONSTRANT(상수)
               변수의 값을 변경할 수 없도록 제약
           Expression
               Literal, 다른 변수, 연산자나 함수를 포함하는 표현식, 즉 값을 의미

 - PL/SQL에서 변수를 사용하는 이유
       변수는 데이터의 임시 저장 영역
       저장된 값을 조작하기 위해 사용
       저장된 값을 반복해서 재사용

 - PL/SQL에서 사용될 변수의 규칙
       반드시 문자로 시작해야 함
       문자나 숫자, 특수문자를 포함할 수 있음
       변수명은 30byte 이하여야 함
       예약어를 포함하면 안됨

 - 대입문으로 변수에 값 지정하기
       1) 변수명 := 값;
               값을 대입할 때는 :=을 사용
       2) SELECT 열이름 INTO 변수명 FROM 테이블;
               테이블에 있는 열이름의 값을 변수명에 저장

 - 변수는 PL/SQL 프로시저인 BEGIN ~ END 사이에서만 실행하는 순간에만 유지되며,
       프로시저 실행이 종료되면 소멸

 - SET SERVEROUTPUT ON;
       DBMS_OUTPUT이 화면에 출력되기 위해 해준다.

주요 변수들의 종류
 - PL/SQL 변수
       단순 변수
           Scalar 변수
           Reference 변수
               %TYPE 변수
               %ROWTYPE 변수
       LOB
       복합 변수
           RECORD TYPE
           TABLE TYPE

 - 비 PL/SQL 변수
       BIND 변수
           
단순 변수
 - Scalar 변수
       단일 값을 가지는 변수의 【데이터 타입을 직접 지정】해주는 변수
           데이터 형은 SQL에서 사용하던 자료 타입과 거의 유사함
       문법
           변수명 [CONSTANT] 데이터타입 [NOT NULL] [:= | DEFAULT Expression];
               CONSTANT
                   읽기전용 변수, 상수로 선언하기 위한 키워드로 초기값이 반드시 지정되야 함
               NOT NULL
	       항상 값을 가지도록 제약을 주는 키워드
                   초기값이 반드시 지정되야 함
               := 또는 DEFAULT
                   변수에 기본값(초기값)을 할당하기 위한 키워드
               Expression
	       변수에 부여할 기본값(초기값)
                   다른 변수나 수식, 함수가 올 수 있음
       예시
           v_num NUMBER(5,3);
               v_num에 숫자를 저장하는 변수로 총 5자리 중 3자리는 소수점(0.000)
           v_name VARCHAR2(12) := '이지은';
               v_name의 타입은 VARCHAR2이고 초기값으로 '이지은'을 줌
       
 - Reference 변수
       데이터 타입을 다른 칼럼에서 참조 후 지정하는 방식
           변수가 지정되어야 할 정확한 데이터 형태를 모를 경우 
               해당 데이터가 들어 있는 칼럼의 정보를 참조
       %TYPE 변수
           이미 선언된 다른 변수나 칼럼의 데이터 타입을 이용하여 선언
           테이블의 칼럼 데이터 타입을 모를 경우 사용
           코딩이후 참조한 칼럼의 데이터 타입이 변경되어도 수정할 필요가 없음
               수정된 데이터 타입을 참조하기 때문에
           예시
               변수명 테이블A.칼럼B%TYPE
                   테이블A의 칼럼B와 동일한 데이터형으로 변수 선언
                       변수명의 데이터형과 크기는 칼럼B와 같다.

       %ROWTYPE 변수
           하나 이상의 데이터 값을 갖는 데이터 타입
               배열과 비슷한 역할을 하고 재사용이 가능
           테이블이나 뷰 내부의 칼럼 데이터타입, 크기, 속성등을 그대로 사용
           지정된 테이블의 구조와 동일한 구조를 갖는 변수를 선언하는 것
           테이블의 칼럼 수나 타입을 알지 못할 경우 사용
           테이블의 칼럼이 변경되어도 수정할 필요가 없음
           예시
           변수명 테이블A%ROWTYPE
               테이블A의 여러 칼럼을 한꺼번에 저장할 변수로 선언
                   ROWTYPE 변수는 하나의 테이블에 여러 칼럼의 값을 한꺼번에 저장할 수 있는 변수를 의미
                       테이블A와 동일한 구조를 갖는 변수명이 생성

 - 참고 : https://goalker.tistory.com/84
           https://psh85a.tistory.com/entry/oracle-TYPE%EA%B3%BC-ROWTYPE
               
PL/SQL
    DECLARE 변수 선언부, 옵션
    BEGIN 로직 기술, 필수
    EXCEPTION 예외처리, 옵션

SELECT문
    SELECT 칼럼명 INTO 변수명 FROM 테이블명 WHERE 조건;
        테이블의 칼럼의 값을 변수명에 대입

선택문
    IF - THEN - END IF
        IF (변수조건) THEN ········· 조건문
            변수조건 예시 → 변수명 = 30
        조건에 만족할 경우 실행되는 문장;
        END IF;

    IF - THEN - ELSE - END IF
        IF (변수조건) THEN ········· 조건문
        조건에 만족할 경우 실행되는 문장;
        ELSE
        조건에 만족하지 않을 경우 실행되는 문장;
        END IF;

    IF - THEN - ELSIF - ELSE - END IF
        IF (변수조건) THEN ········· 조건문
        조건에 만족할 경우 실행되는 문장;
        ELSIF (변수조건) THEN ········· 조건문2
        조건에 만족할 경우 실행되는 문장;
        ELSE
        조건에 만족하지 않을 경우 실행되는 문장;
        END IF;

반복문
 - 반복문의 종류
       BASIC LOOP문
           조건 없이 반복 작업을 제공
           LOOP
               실행할 문장;
               EXIT [WHERE 조건];
           END LOOP

       FOR LOOP문
           COUNT를 기본으로 작업의 반복 제어를 제공
           FOR index_counter
               // index_counter
                      upper_bound나 lower_bound에 도달할 때까지 반복함으로써
                      1씩 자동적으로 증가하거나 감소되는 값을 가진 정수
           IN [REVERSE] lower_bound..upper_bound LOOP
               // REVERSE
                      upper_bound에서 lower_bound까지 반복함으로써 인덱스가 1씩 감소
               // lower_bound 
	          index_counter 값의 범위에 대한 최소값을 지정
               // upper_bound
                      index_counter 값의 범위에 대한 최대값을 지정
               실행할 문장;
           END LOOP

       WHILE LOOP문
           조건을 기본으로 작업의 반복 제어를 제공
           WHILE 조건 LOOP
               실행할 문장;
           END LOOP

       EXIT문
           LOOP를 종료

 - BASIC LOOP문 예시
       DECLARE 
           N NUMBER := 1;
       BEGIN
           LOOP
               DBMS_OUTPUT.PUT_LINE(N);
               N := N+1;
               IF (N>5) THEN
                   EXIT;
               END IF;
           END LOOP;
       END;
       /

 - FOR LOOP문 예시
       DECLARE
           SUM NUMBER := 0;
       BEGIN
           FOR N IN 1..100 LOOP
               SUM := SUM + N;
           END LOOP;
           DBMS_OUTPUT.PUT_LINE(SUM);
       END;
       /

 - WHILE LOOP문 예시
       DECLARE
           N NUMBER := 1;
           TOTAL NUMBER := 0;
       BEGIN
           WHILE N<=5 LOOP
               TOTAL := TOTAL+1;
               N := N+1;
               DBMS_OUTPUT.PUT_LINE(TOTAL);
               DBMS_OUTPUT.PUT_LINE(N);
           END LOOP;
       END;
       /

저장 프로시저
 - PL/SQL문을 저장해 놓는 공간
       저장 프로시저를 실행하면 프로시저에 저장된 PL/SQL문이 실행되는 것 

 - 저장 프로시저 생성하기
       CREATE [OR REPLACE] 프로시저명
           ( argument1 [mode] data_taye,
             argument2 [mode] data_taye
           )
       IS 로컬변수
       BEGIN
           실행할 문장;
       END;
       /

 - 저장 프로시저 실행하기
       EXECUTE 프로시저명;

 - 저장 프로시저 조회하기
       SELECT * FROM USER_SOURCE WHERE NAME = '프로시저명';

 - 저장 프로시저의 매개변수
       CREATE OR REPLACE PROCEDURE 프로시저명(변수명 테이블.칼럼명%TYPE)
       IS
       BEGIN
           실행할 문장;
       END;
       /
       EXECUTE 프로시저명(매개변수);

 - IN, OUT, INOUT 매개변수
       프로시저를 생성할 때 매개변수의 3가지 MODE
           DEFAULT는 IN
       IN : 데이터를 전달 받을 때 사용
                외부에서 들어오는 매개변수를 사용
       OUT : 수행된 결과를 받아 갈 때 사용
                   외부에서 입력한 매개변수에 값을 저장
       INOUT : IN + OUT

       ex) CREATE OR REPLACE PROCEDURE SEL_EMPNO(
	    VEMPNO IN EMP.EMPNO%TYPE,
    	    VENAME OUT EMP.ENAME%TYPE,
	    VSAL OUT EMP.SAL%TYPE,
	    VJOB OUT EMP.JOB%TYPE)
           IS
           BEGIN
               SELECT ENAME, SAL, JOB INTO VENAME, VSAL, VJOB FROM EMP WHERE EMPNO = VEMPNO;
           END;
           /    

          변수 선언
               VARIABLE VAR_ENAME VARCHAR2(15);
               VARIABLE VAR_SAL NUMBER;
               VARIABLE VAR_JOB VARCHAR2(9);
          저장 프로시저 실행
              EXECUTE SEL_EMPNO(1001, :VAR_ENAME, :VAR_SAL, :VAR_JOB); 
                  // :변수명
                         선언된 변수를 사용한다는 의미
          바운드 변수의 값을 출력
              print var_ename
              print var_sal
              print var_job

       IN으로 받은 매개변수는 프로시저 안에서 소비하는 것
       OUT으로 받은 매개변수는 프로시저 안에서 결과를 얻어서
           EXECUTE로 실행할 때 값을 리턴해주는 것     

저장 프로시저를 사용하는 이유
    클라이언트 응용프로그램에서 반복적으로 같은 처리를 할 경우
        매번 같은 SQL문을 서버에 보내는 대신
        미리 정의를 서버에 저장해 두고 클라이언트에서는 단순히 이 프로시저를
        적당한 매개변수와 함께 호출만 해 주면 서버에서 
        해당 프로시저의 정의를 읽어서 곧바로 실행하게 되는 것

    저장 프로시저를 사용하면 클라이언트/서버 간 네트워크 트래픽이 줄어들어서
        서버에서는 미리 복잡한 쿼리를 모아서 좀 더 실행하기 좋은 형식으로 관리할 수 있다.
        즉 처리 속도가 빠르다
     
저장 함수
 - 저장 프로시저와 거의 유사한 용도로 사용
 - 차이점은 함수는 실행 결과를 되돌려 받을 수 있다는 점.
 - CREATE [OR REPLACE] FUNCTION 저장함수명
       (argument1 [mode] data_taye,
        argument2 [mode] data_taye ...
            //저장 함수의 매개변수
        )
       RETURN NUMBER
           //저장 함수의 리턴 타입
   IS
       내부에서만 사용할 지역 변수를 선언
   BEGIN
       statement1;
       statement2;
           //실행할 문장
       RETURN variable_name;
           //실행 결과 리턴
   END;

 - 예시
    1. 저장함수 만들기
        CREATE OR REPLACE FUNCTION CAL_BONUS(
            VEMPNO IN EMP.EMPNO%TYPE -- 매개변수
        )
        RETURN NUMBER -- 저장 함수의 리턴 타입
        IS
            VSAL NUMBER(7,2); -- 로컬 변수
        BEGIN
            SELECT SAL INTO VSAL FROM EMP WHERE EMPNO = VEMPNO; -- 실행할 문장
            RETURN (VSAL*200); -- 실행 결과 리턴
        END;
        /
    2. 바운드 변수 선언하기
        VARIABLE var_res number;
    3. 저장 함수 실행하기
        EXECUTE :var_res := CAL_BONUS(1001);
    4. 바운드 변수 출력하기
        print var_res;
    5. 저장함수를 호출하는 SQL문장
        SELECT sal, CAL_BONUS(1001) FROM emp WHERE empno = 1001;

커서
 - 여러 개의 행으로 구해지는 SELECT문을 처리하기 위해 사용
 - 자바의 Iterator와 비슷
 - DECLARE
       CURSOR 커서명 IS statement;
           //커서 선언
                 statement : 실행할 문장
   BEGIN
       OPEN 커서명
           //커서 열기
       FECTCH 커서명 INTO 변수명;
           //커서로부터 데이터를 읽어와 변수에 저장
       CLOSE 커서명;
           //커서 닫기
   END;
   /

 - DECLARE : 이름있는 SQL 영역 생성
   OPEN : active set을 지정
   FETCH : 현재 행을 READ하여 변수에 저장,
                 결과 셋에서 로우 단위로 데이터를 읽어 들인다.
   EMPTY : 처리할 행이 있는지 검사
                  처리할 행이 있다면 FETCH를 반복
   CLOSE : active set을 release(반환)

 - 커서의 상태
       %NOTFOUND
           커서 영역의 자료가 모두 FETCH됐다면 TRUE
       %FOUNT
           커서 영역에 FETCH되지 않은 자료가 있다면 TRUE
       %ISOPEN
           커서가 OPEN된 상태면 TRUE
       %ROWCOUNT 
           커서가 얻어 온 레코드의 갯수

 - 예시
       CREATE OR REPLACE PROCEDURE CURSOR_SAMPLE01 
       IS
           VDEPT DEPT%ROWTYPE;
           CURSOR  C1
           IS
               SELECT * FROM DEPT;
       BEGIN
           DBMS_OUTPUT.PUT_LINE('부서번호    부서명   지역명');
           DBMS_OUTPUT.PUT_LINE('------------------------');
   
           OPEN C1;
   
           LOOP
               FETCH  C1  INTO  VDEPT.DEPTNO, VDEPT.DNAME, VDEPT.LOC;
               EXIT WHEN C1%NOTFOUND;
   
               DBMS_OUTPUT.PUT_LINE(VDEPT.DEPTNO ||  '   ' || VDEPT.DNAME || '     ' || VDEPT.LOC );
           END LOOP;
   
           CLOSE C1;
       END;
       /

 - OPEN~FETCH~CLOSE가 없이 FOR LOOP ~ END LOOP로 사용할 수 있다.
       간단하게 커서를 처리할 수 있는 방법
           FOR 변수명 IN 커서명 LOOP
	   실행할 문장;
               EXIT WHEN C1%NOTFOUND;
           END LOOP;

TRIGGER(트리거)
 - 데이터베이스에서 테이블이나 뷰에 INSERT, UPDATE, DELETE 등의 (DML)
       이벤트 발생시 자동으로 실행되도록 사용자가 정의해놓은 프로시저

 - 특정 테이블이 변경되면 다른 테이블이 자동으로 변경되도록 하기 위해서 사용

 - 트리거의 단점
       1) 트리거를 생성하고 관리하려면 반드시 문서화가 필요하고,
              인수인계시 트리거의 유무를 알려줘야 하는데
              유지 보수에서 운영 포인트가 하나 늘어나는 것
       2) 되도록이면 트리거에는 비즈니스 로직은 넣지 않는다.
              만약 트리거 안에서 UTL_HTTP를 써서 API URL을 호출하도록 작성하였을 경우
              테이블에 이벤트가 발생해서 트리거가 작동을 한 뒤
              롤백을 해도 트리거는 롤백이 가능하지만 호출된 API는 롤백을 할 수 없다.

 - DB에서 테이블을 찾아서 우클릭 → 트리거 → 생성
 - 구조
       CREATE TRIGGER 트리거명
       timing[BEFORE | AFTER] event[INSERT | UPDATE | DELETE] ON 테이블명;
       [FOR EACH ROW]
       [WHEN conditions]
       BEGIN
           statement
       END;
       /

 - 트리거 작성시 주요 내용
       timing
           BEFORE
               어떤 테이블에 DML문이 실행될 때 해당 문장이 실행되기 전에
               트리거가 가지고 있는 BEGIN ~ END 사이의 문장을 실행
           AFTER
               DML문이 실행될 때 해당 문장이 실행되고 난 후에
               트리거가 가지고 있는 BEGIN ~ END 사이의 문장을 실행
       event
           사용자가 어떤 DML문을 실행했을 때 트리거를 발생시킬 것인지 결정
               여러 개를 사용할 경우 OR로 구분
                   ex) INSERT OR DELETE OR UPDATE
       BEGIN ~ END
           해당 타이밍에 해당 이벤트가 발생하게 되면 실행될 기본 로직이 포함되는 부분
           BEGIN ~ END 사이에 기술
       FOR EACH ROW
           FOR EACH ROW에 의해 문장 레벨 트리거와 행 레벨 트리거로 나뉨
           FOR EACH ROW가 생략되면 문장 레벨 트리거
                                   생략되지 않으면 행 레벨 트리거
           문장 레벨 트리거는 어떤 사용자가 트리거가 설정되어 있는 테이블에 대해
               DML문을 실행할 때 【단 한 번만】 트리거를 발생시킬 때 사용
           행 레벨 트리거는 DML문을 실행할 때 【행마다】 트리거를 발생시킬 때 사용
       WHEN conditons
           행 레벨 트리거에서만 설정할 수 있음
           이벤트에 정의된 테이블에 이벤트가 발생할 때보다 
               구체적인 데이터 검색 조건을 부여할 때 사용


/*
 - SYSDATE : 년, 월, 일까지만 나옴
     SYSTIMESTAMP : 년, 월, 일, 시, 분, 초까지 나옴

 - order by는 항상 마지막에 적는다.

 - 제약조건이름도 중복이 안되니 확인하기

 - ERD 표에서 윗칸은 기본키

 - ROW_NUMBER : 로우에 순번을 매겨줌

 - ( )안에 작성하면 ( )안에 있는 식부터 처리한다.

 - SHOW AUTOCOMMIT;
       현재 autocommit의 상태를 보여줌

 - SHOW USER
       현재 사용중인(접속한) 계정을 보여줌

*/
