DBMS(DataBase MAnagement System)
 - 데이터 베이스를 관리해주는 프로그램
 - 다수의 사용자들이 데이터베이스 내의 
    데이터를 접근할 수 있도록 해주는 소프트웨어 도구의 집합

Schema : 연관된 테이블들을 그룹핑하는 일종의 디렉토리(폴더)
사용자 : 사용자를 생성하면 사용자에 속하는 스키마가 만들어지고
	  사용자는 그 안에 있는 테이블에 접속할 수 있음
※ 사용자 = 스키마는 아니지만 둘은 항상 세트

SQL(Structured Query Language)
 - 데이터 베이스에 명령을 주는 것
       구조화된 정보를 처리하도록 요청하는 컴퓨터 언어
 - 엑셀보다 불편하고 어려운데 DB를 사용하는 이유
   · 물리적 한계
        엑셀은 물리적으로 많은 데이터를 넣기가 힘들다. 최대 65000여개

   · 명령어를 통해 DB를 제어할 수 있다
        명령어를 컴퓨터 프로그램을 통해 데이터를 자동적으로 만들 수 있다.
        명령어를 통해 데이터를 가공하고 가치있는 무언가를 만드는 것을 자동화 할 수 있다.

SQL 명령어의 유형
 - DQL(Data Query Language, 질의어)
   · SELECT : 데이터 검색시 사용★★★
 
 - DML(Data Manipulation Language, 데이터 조작어)
   · INSERT : 데이터 입력
   · UPDATE : 데이터 수정
   · DELETE : 데이터 삭제

 - DDL(Data Definition Language, 데이터 정의어)
   · CREATE : 데이터베이스 생성
   · ALTER : 데이터베이스 변경, 기존의 테이블 수정(추가, 크기변경 등)
   · DROP : 데이터베이스 삭제, 테이블 자체를 삭제
   · TRUNCATE : 데이터베이스 저장 공간 삭제, 
                     테이블에 저장된 모든 내용을 삭제(테이블은 남아있음)
   · RENAME : 데이터베이스 객체이름 변경, 테이블 이름 변경

 - TCL(Transaction Control Language, 트랙잭션 처리어)
        ※ Transaction : 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위
   · COMMIT : 트랜잭션의 정상적인 종료처리, 변경된 내용을 영구 저장
   · ROLLBACK : 트랜잭션 취소, 변경되기 이전 상태로 되돌림
   · SAVEPOINT : 트랜잭션 내에 세이브포인트 설정

 - DCL(Data Control Language, 데이터 제어어)
   · GRANT : 데이터베이스에 대한 일련의 권한 부여
   · REVOKE : 데이터베이스에 대한 일련의 권한 취소

사용자 계정 만들기
 - CREATE USER 사용자ID IDENTIFIED BY 사용자PW;

역할 부여하기
 - GRANT 키워드를 사용
 - CONNECT : 접속할 수 있는 권한을 줌
 - RESOURCE : DDL 권한을 줌
 - 사용자 계정 만들기와 역할 부여 권한은 system에게만 있다.

데이터 타입
 - CHAR(size)
   · size 크기의 고정 길이 문자 데이터 타입
     크기를 10으로 지정하고 지정된 길이보다 짧은 데이터가 입력되면
     남은 칸은 공백으로 채워짐
   · 최대타입 : 2000바이트
   · 최소타입 : 1바이트

 - VARCHAR2(size)
   · size 크기의 가변 길이 문자 데이터 타입
     크기를 50으로 줘도 저장되는 데이터의 길이가 6이면
     길이가 6만 할당된다.
   · 최대타입 : 4000바이트
   · 최소타입 : 1바이트
   · 한글은 2바이트

 ※ VARCHAR와 VARCHAR2는 동의어
        VARCHAR는 나중에 다른 데이터 타입으로 바뀔 수 있기 때문에
        왠만하면 VARCHAR2를 사용

 - NVARCHAR2(size)
   · 국가별 문자 집합에 따른 size 크기의 
   · 문자 또는 바이트의 가변 길이 문자 데이터 타입
     크기를 50으로 줘도 저장되는 데이터의 길이가 6이면
     길이가 6만 할당된다.
   · 최대크기 : 4000바이트
   · 최소크기 : 1바이트

 - NUMBER(p,s)
   · p칸의 소수점 s자리
     ex) number(8,2) : 000000.00
          123456.789가 들어오면 반올림되서 123456.79가 들어감
          정수가 넘치면 늘어남
   · p : 1 ~ 38
   · s : -84 ~ 127
   · 매개변수가 없으면 가변 길이가 된다.

 - DATE
   · 날짜 형식을 저장하기 위한 데이터 타입
   · 컬럼을 만들고 자료를 삽입할 때 
     to_date('xxxx-xx-xx','yyyy-MM-dd') 이런 식으로 사용

 - ROWID
   · 데이터베이스에서 데이터마다의 주소를 의미
   · 각각의 데이터를 구분할 수 있는 유일한 ID
   · 구조
     - 오브젝트 번호(32bit,6자리) : 해당 데이터가 속하는 오브젝트 번호
		                   오브젝트별로 유일값을 가지고 있다.
     - 상대 파일 번호(10bit,3자리) : 테이블스페이스는 여러 개의 DATAFILE을 생성할 수 있다.
			        10bit이기 때문에 테이블스페이스당 1023개의 DATAFILE을 추가 가능
			        DATAFILE은 해당 테이블스페이스의 상대 파일 번호를 의미
			        각 데이터별로 유일한 값을 가짐
     - 블록 번호(22bit,6자리) : 파일 안에 어느 블록인지 의미
     - 데이터 번호(16bit,3자리) : 오브젝트 번호, 파일번호, 블록 번호가 같으면 데이터 번호는 
			    블록별로 데이터가 저장되어 있는 순서를 의미
     = 총 80bit(18자리) = 10byte

 - BLOB
   · 대용량의 바이너리 데이터를 저장하기 위한 데이터 타입
   · 최대크기 : 4GB
   · 이미지를 쓸 때 사용

 - CLOB
   · 대용량의 텍스트 데이터를 저장하기 위한 데이터 타입
   · 최대크기 : 4GB
             
 - BFILE
   · 대용량의 바이너리 데이터를 파일 형태로 저장하기 위한 데이터 타입
   · 최대크기 : 4GB

 - TIMESTAMP(n)
   · DATE 데이터 타입의 확장된 형태
   · n은 milli second 자리수로 최대 9자리까지 표현 가능

 - INTERVAL YEAR TO MONTH
   · 년과 월을 이용하여 기간을 저장
 
 - INTERVAL DAY TO SECOND
   · 일, 시, 분, 초를 이용하여 기간을 저장
   · 두 날짜값의 정확한 차이를 표현하는데 유용

SELETE문
 - SQL의 가장 기본이 되는 문장
 - 테이블에 있는 자료를 검색할 때나, 함수를 써서 데이터를 보여줄 때 사용

 - SELECT 컬럼명 FROM 테이블명;이 기본 구조
    [ ]는 생략 가능하다는 의미,
    { , , }는 안에 있는 것 중 하나를 쓰면 된다는 의미
   · SELECT * FROM 테이블명 : 테이블에 있는 모든 레코드 출력, * = ALL
     만약 부분만 필요하면 SELECT 컬럼명1, 컬럼명2 FROM 테이블명;

 - DISTINCT : 중복 제거
    ex) SELECT DISTINCT job FROM emp;
         emp 테이블의 job행에서 중복을 제거한 결과를 보여줌

 - 연산이 필요한 경우
    ex) SELECT sal, sal*0.03 FROM emp;
         sal행과 sal행*0.03의 결과를 보여줌

 - 컬럼에 들어있는 값이 NULL인 경우 연산이 불가능하기 때문에
    NVL함수를 사용
    ex) SELECT comm, sal*12+comm, NVL(comm,0),sal*12+NVL(comm,0) FROM emp;
         comm의 값이 NULL이면 0을 넣어서 계산해라

 - 컬럼에 별칭 부여하기
   · as 뒤에 별칭을 쓰거나 그냥 별칭만 쓴다.
   · " "로 별칭을 부여한다.
   ex) SELECT DISTINCT job [as] 직위 FROM emp;
        SELECT DISTINCT job "직위" FROM emp;

 - Concatenation 연산자
   · 여러 개의 컬럼을 연결할 때 사용
     ||를 컬럼과 문자열 사이에 기술하여 하나로 연결
     ex) SELECT ename || '의 직급은 '|| job || '입니다.' 직급 from emp;

WHERE(조건절)
 - 원하는 row만 얻으려면 로우를 제한하는 조건을 제시
 - 비교 연산자
   · = : 같다
   · > : 크다
   · < : 작다
   · >= : 크거나 같다
   · <= : 작거나 같다
   · <>,!=,^= : 다르다
   · 날짜의 경우 이 전이면 작은 것, 이 후면 큰 것

 - 논리 연산자
   · AND : 두 조건 모두 참인 것만 검색
   · OR : 두 조건 중 하나만 참이어도 검색
   · NOT : 두 조건 다 거짓인 것만 검색

 - BETWEEN AND 연산자
   · BETWEEN a AND b : a와 b 사이
   · 특정 범위 내에 속하는 데이터인지 알아본다.
     ex) SELECT * FROM emp where sal between 400 and 500;
          SELECT * FROM emp where sal >= 400 and sal <= 500;과 같다.

 - IN 연산자
   · 특정 필드의 값이 A이거나 B이거나 C 중 하나만 만족하더라도 출력
   · in() : ~안에
     ex) SELECT * FROM emp where comm in(80,100,200);
          SELECT * FROM emp where comm = 80 or comm = 100 or comm = 200;과 같다.

 - LIKE 연산자와 와일드카드
   · LIKE : 유사일치(비슷하게라도 일치하는 것)
   · LIKE 다음에는 pattern을 기술해야 하는데 %와 _ 와일드카드가 있다.
     - % : 문자가 없거나, 하나 이상의 어떤 문자가 와도 상관없음
     - _ : 하나의 문자가 어떤 값이 와도 상관없음.
     ※ 문자가 없어도 되는 경우 %, 꼭 1개는 있어야 하는 경우 _를 사용

 - NULL인 값을 찾기 위한 IS NULL
   · SELECT * FROM emp where comm is null;
     comm의 값이 null인 것 찾기
   · SELECT * FROM emp where comm is not null;
     comm의 값이 null이 아닌 것 찾기

 - 정렬을 위한 ORDER BY절
   · ORDER BY 컬럼 : 컬럼을 기준으로 정렬
   · asc : 오름차순, 생략 가능
   · desc : 내림차순
   · NULL의 경우 오름차순이면 가장 마지막에 출력
	         내림차순이면 가장 먼저 출력
   · 여러 가지 조건 제시
     ex) 입사일이 느린 순으로 출력하되 입사일이 같으면 이름순으로 출력
          SELECT * FROM emp order by hiredate desc, ename;

집합 연산자
 - UNION(합집합)
   · select * from group_star UNION select * from single_star; (중복 x)
   · select * from group_star UNION ALL select * from single_star; (중복 o)
   · ALL이 붙으면 중복된 데이터까지 포함
     UNION만 가지고 있다.

 - DIFFERENCE(차집합)
   · select * from group_star MINUS select * from single_star;

 - INTERSECT(교집합)
   · select * from group_star INTERSECT select * from single_star;
 ※ 테이블 집합 테이블 순서

Dual 테이블
 - 바로 산술 연산의 결과를 한 줄로 얻음
   · select * from dual; = X라는 결과가 나옴
   · select 24*60 from dual; = 1440

숫자 함수
 - 숫자 데이터를 처리하기 위한 함수
   · ABS : 절대값을 구함
     - select ABS(-10) from dual; = 10

   · COS : COSINE값을 반환

   · EXP : e(2.71828183 ··· )의 n승을 반환

   · FLOOR : 소수점 아래를 잘라버림
     - select FLOOR(34.5678) from dual; = 34

   · LOG : LOG 값을 반환

   · POWER : POWER(m,n), m의 n승을 반환

   · SIGN : SIGN(n) n<0이면 -1, n=0이면 0, n>0이면 1을 반환

   · SIN : SINE 값을 반환

   · TAN : TANGENT 값을 반환

   · ROUND : 특정 자리수에서 반올림
     - select round(3.83, 1) from dual; = 3.8
        소수점 한자리까지 표시
        소수점 2번째 자리를 반올림

   · TRUNC : 특정 자리수에서 잘라버림
     - select TRUNC(34.5678, 2) from dual; = 34.56
     - select TRUNC(34.5678, -1) from dual; = 30
     - select TRUNC(34.5678) from dual; = 34
   ※ ROUND와 TRUNC에서 2번째 매개값이 음수면 1의 자리, 10의 자리, ...
				      양수면 소수점 첫번째, 두번째, ...
				       0이면 소수점 전체를 잘라버림

   · MOD : 입력 받은 수를 나눈 나머지 값을 반환
     - select mod(10, 3) from dual; = 1
        10/3의 나머지
        자바의 %와 같다.

문자 처리 함수
 - 문자형의 값을 조작하여 변환된 문자 값을 반환하는 함수
 - 대 · 소문자간의 변환을 위한 함수와
    문자열을 정교하게 조작하는 함수로 나뉨

 - 대소문자 변환함수
   · UPPER : 전부 대문자
     - select UPPER('Welcome') from dual; = WELCOME
   · LOWER : 전부 소문자
     - select LOWER('wELcome') from dual; = welcome
   · INITCAP : 첫 글자만 대문자, 나머지는 소문자
     - select INITCAP('welcome') from dual; = Welcome

 - 문자 길이를 구하는 함수
   · LENGTH : 문자 길이를 반환(한글 1byte)
     - select LENGTH('Oracle') from dual; = 6
     - select LENGTH('오라클') from dual; = 3
   · LENGTHB : 문자 길이를 바이트로 반환(한글 2 혹은 3byte)
     - select LENGTHB('Oracle') from dual; = 6
     - select LENGTHB('오라클') from dual; = 9

 - 문자 조작 함수
   · CONCAT : 문자끼리 연결
     - select CONCAT('ab','cd') from dual; = 'abcd', 2개만 연결 가능

   · SUBSTR : 문자를 잘라서 추출(한글 1byte)
     - select SUBSTR('Welcome to Oracle', 2, 3) from dual; = 'elc'

   · SUBSTRB : 문자를 잘라서 추출(한글 2~3byte)
     - select SUBSTRB('가나다라마바사', 2, 5) from dual = 나
        2바이트부터 5바이트 읽기
        완벽하게 3바이트가 포함된 글자만 출력
        가는 2,3만 포함되고 1이 포함되지 않아서 출력이 안된 것
        나는 4,5,6이 포함되서 출력

   · INSTR : 특정 문자의 위치 값을 반환(한글 1byte)
     - select INSTR('데이터베이스', '이', 4, 1) from dual; = 5
       매개값은 대상, 찾을 글자, 시작 위치, 시작위치부터 몇번째에 있는 것

   · INSTRB : 특정 문자의 위치 값을 반환(한글 2~3byte)
     - select INSTRB('데이터베이스', '이', 4, 1) from dual; = 4
        4바이트부터 '이'가 있는 바이트의 시작 바이트 수를 리턴
        4바이트에서 시작해서 '이'가 4바이트에 있으니 4,5,6바이트 중 4바이트를 반환

   · LPAD, RPAD : 입력 받은 문자열과 기호를 정렬하여 특정 길이의 문자열로 반환
     - select LPAD('Oracle', 20, '#') from dual; = ##############Oracle
        자리를 20칸 마련하고 데이터를 오른쪽부터 채우고 남은 칸은 #으로 채움
        왼쪽에서 값이 들어오고 나머지는 기호로 채움
     - select RPAD('Oracle', 20, '#') from dual; = Oracle##############
        자리를 20칸 마련하고 데이터를 왼쪽부터 채우고 남은 칸은 #으로 채움
        오른쪽에서 값이 들어오고 나머지는 기호로 채움

 - 형변환 함수
   · 자료형을 변환시키고자 할 때 사용
   · TO_CHAR : 날짜형 or 숫자형을 문자형으로 변환
     - TO_CHAR(날짜 데이터, '출력형식')
     - 날짜 출력 형식
       · YYYY : 년도 표현(4자리)
       · YY :  년도 표현(2자리)
       · MM : 월을 숫자로 표현
       · MON : 월을 알파벳으로 표현
       · DAY : 요일 표현
       · DY : 요일을 약어로 표현
     ex) select sysdate, to_char(sysdate,'yyyy/MM/dd') from dual;
          sysdate : 컴퓨터의 현재 시간을 가져오는 것
     - 시간 출력 형식
       · AM or PM : 오전, 오후 시각 표시
       · HH or HH12 : 시간(1~12)
       · HH24 : 시간(0~23)
       · MI : 분 표현
       · SS : 초 표현
     ex) select sysdate, to_char(sysdate,'yyyy/MM/dd, AM HH:MI:SS') from dual;
     - 숫자형을 문자형으로 변환
       · 0 : 자릿수를 나타내며 자릿수가 맞지 않을 경우 0으로 채움
       · 9 : 자릿수를 나타내며 자릿수가 많지 않을 경우 공백
       · L : 각 지역별 통화 기호
       · . : 소수점
       · , : 천 단위 자리 구분
     ex) select to_char(123400, 'L999,999,999') from dual; = \123,400

   · TO_DATE : 문자형을 날짜형으로 변환
     - TO_DATE('문자', 'format')
     ex) select to_date(sysdate,'yyyy/MM/dd') from dual;
          sysdate 자리에 문자형으로 임의의 날짜를 지정할 수 있음

   · TO_NUMBER : 문자형을 숫자형으로 변환
     - select to_number('199999') from dual;
   ※ 단 문자형이 숫자로만 이루어져 있어야 TO_DATE나 TO_NUMBER로 변환 가능

 - 날짜 함수
   · DATE형에 사용하는 함수
   · 결과 값으로 날짜 또는 시간을 얻음
     - SYSDATE : 시스템에 저장된 현재 날짜를 반환

     - MONTHS_BETWEEN : 날짜와 날짜 사이의 개월 수를 구함
       · select ename, sysdate 오늘, to_char(hiredate, 'yyyy/mm/dd')
                                          , trunc(MONTHS_BETWEEN(sysdate, hiredate)) from emp;

     - ADD_MONTHS : 특정 개월 수를 더한 날짜를 구함
       · select ename, to_char(add_months(hiredate, 6), 'yyyy-mm-dd') from emp;
         hiredate에 6개월을 더한 값을 출력

     - NEXT_DAY : 해당 요일의 가장 가까운 날짜를 반환
       · select to_char(sysdate, 'yyyy/mm/dd'), to_char(NEXT_DAY(sysdate, 'MONDAY'),'yyyy/mm/dd') from dual;
         이렇게 사용하면 오류 발생
         현재 컴퓨터 시스템의 국가형식이 대한민국이라서 영어요일은 오류 발생
         한국 요일이나 숫자를 사용해야 한다(일=1, 월=2, ...) 
       · select to_char(sysdate, 'yyyy/mm/dd') 오늘,
                 to_char(next_day(sysdate,'월'),'yyyy/mm/dd') 월요일
                 from dual;
       · select to_char(sysdate, 'yyyy/mm/dd') 오늘,
                 to_char(next_day(sysdate,2),'yyyy/mm/dd') 월요일
                 from dual;

     - LAST_DAY : 각 월의 마지막 날짜를 반환
       · select ename, to_char(hiredate,'yyyy/mm/dd'), to_char(last_day(hiredate), 'yyyy/mm/dd') from emp;

     - ROUND : 인자로 받은 날짜를 특정 기준으로 반올림
       · ROUND(date, format)
       · 숫자 이외에 날짜에 대해서도 반올림 가능
         - CC, SCC : 4자리 연도의 끝 두 글자를 기준으로 반올림
         - SYYY, YYYY, YEAR, SYEAR, YYY, YY, Y : 년(7월 1일부터 반올림)
         - DDD, D, J : 일을 기준
         - HH, HH12, HH24 : 시를 기준
         - Q : 한 분기의 두 번째 달의 16일을 기준으로 반올림
         - MONTH, MON, MM, RM : 월(16일을 기준)
         - DAY, DY, D : 한 주가 시작되는 날짜
         - MI : 분을 기준   
       · select to_char(hiredate, 'yyyy/mm/dd') 입사일, to_char(round(hiredate, 'YEAR'),'yyyy/mm/dd') 입사일 from emp;

     - TRUNC : 인자로 받은 날짜를 특정 기준으로 버림
       · TRUNC(date, format)
       · select TO_CHAR(TRUNC(hiredate, 'MONTH'), 'yyyy/MM/dd') from emp;

NULL을 다른 값으로 변환하는 함수
 - NVL 함수는 NULL을 0 또는 다른 값으로 변환
   · NVL(expr1, expr2) = expr1이 null이면 expr2로 반환
   · NVL2(expr1, expr2, expr3) = expr1이 null이 아니면 expr2를 반환, null이면 expr3를 반환

 - NULLIF : 두 표현식을 비교하여 동일하면 null, 다르면 첫번째 값을 반환
   · NULLIF(expr1, expr2)
     동일하지 않으면 expr1 반환
     동일하면 null 반환
   · ex) select nullif('a','a'),nullif('a','b') from dual; = null, a


 - COALESCE 함수
   · null이 아닌 첫 번째 인수를 반환
   · null을 빼고 첫번째로 나오는 값
   · ex) select coalesce('a','b','c','d') from dual; = a
         select coalesce('a','b',null,'c','d') from dual; = a
         select coalesce('a','b','c',null,'d') from dual; = a

DECODE 함수
 - switch case 문과 같은 기능
   · select ename, deptno, decode(deptno, 10, '경리부',
                                                       20, '인사과',
                                                       30, '영업부',
                                                       40, '전산부',
                                                       deptno) from emp; 
  				       ↑어디에도 포함되지 않는 경우


조건에 따라 서로 다른 처리가 가능한 CASE
 - CASE는 다양한 비교 연산자를 이용하여 조건을 제시할 수 있으므로 
    범위를 지정할 수도 있음
 - if else-if else와 유사한 구조
   · case when 기준 = 값 then 출력할 결과
   · select ename, deptno, 
     case when deptno = 10 then '경리부'
            when deptno = 20 then '인사부'
            when deptno = 30 then '영업부'
            when deptno = 40 then '전산부'
            end as dname from emp;

그룹 함수
 - 단일행 함수는 값이 들어오면 들어온 갯수만큼 나감
    그룹 함수는 값이 들어오면 종합해서 1개만 나감
   · SUM : 그룹의 누적 합계를 반환
   · AVG : 그룹의 평균을 반환
   · COUNT : 그룹의 총 개수를 반환
     - null 값은 세지 않음
     - COUNT(*) : 테이블의 전체 로우(행) 수를 구함
   · MAX : 그룹의 최대값
   · MIN : 그룹의 최소값
   · STDDEV : 그룹의 표준편차
   · VARIANCE : 그룹의 분산을 반환

Group by절
 - 특정 컬럼을 기준으로 그룹 함수를 사용해야 할 경우
     어떤 컬럼 값을 기준으로 그룹 함수를 적용해 줄지를 결정할 때 사용
   · 부서별로 총합(부분합)
      select deptno, sum(sal) from emp group by deptno;
   · 직급별로 총합(부분합)
      select job, sum(sal) from emp group by job;
   · 부서별 직급이 사원인 사람들의 월급 총합
      select deptno, sum(sal) from emp where job='사원' group by deptno;
   · 김씨 성을 가진 사람들의 월급 평균
      select job, avg(sal) from emp where ename like '김%' group by job;
   · 입사일이 2000년부터 2003년 사이
      select job, avg(sal) from emp where substr(hiredate, 1, 2) in('00','01','02','03') group by job;
   · 부서번호, 최대값, 최소값을 구해서 최대값 오름차순으로 정렬
      select deptno, max(sal), min(sal) from emp group by deptno order by max(sal);

그룹 결과 제한 HAVING절
 - SELECT절에 조건을 사용하여 그룹의 결과를 제한할 때 사용
    (그냥 결과를 제한할 때는 WHERE절 사용)
   · 평균이 500 이상만 출력
      select deptno, avg(sal), max(sal), min(sal) from emp group by deptno having avg(sal) >= 500;

※ select deptno, avg(sal), max(sal), min(sal) from emp group by deptno having avg(sal) >= 500 order by deptno;
   순서가 정해져 있는것, 
   검색 1등 WHERE조건절 2등 그룹 3등 HAVING조건절 4등 정렬 5등


INSERT : 행 추가
	INSERT INTO 테이블명[(컬럼명1, 컬럼명2, ... )] values(값1, 값2, ...);
	NULL값 넣기 : 값으로 null을 주거나, 값으로 ''만 넣는다.
	날짜 입력은 직접 쓰거나 TO_DATE를 사용

UPDATE : 행 수정
	 UPDATE 테이블명 SET 수정될컬럼명 = 수정될값 WHERE 컬럼명 = 값
	 UPDATE는 WHERE절과 같이 사용
	     (WHERE를 사용하지 않으면 모든 행이 수정된다.)
	 연산도 가능하다
	     UPDATE 테이블명 SET 컬럼명 = 컬럼명 + 100;

DELETE : 행 삭제
	DELETE [FROM] 테이블명 WHERE 컬럼명 = 값;
	UPDATE와 마찬가지로 WHERE절과 같이 사용
	WHERE절의 조건이 2개인 경우
	    DELETE 테이블명 WHERE 컬럼명 = 값 and 컬럼명 = 값;
	WHERE절의 조건에서 값이 null인 경우를 찾을 때 in null 사용
	    DELETE 테이블명 WHERE 컬럼명 is null;

오라클은 트랜잭션을 기반으로 데이터의 일관성을 보장한다.
트랜잭션이란?
 - 데이터 처리에서 논리적으로 하나의 작업 단위를 의미
 - db시점에서는 커밋 롤백의 개념
 - jdbc에서는 자바에서 sql문을 하나하나 보낼 때마다 자동커밋이 되기 때문에
       자동커밋을 끄고 작업을 해서 마지막까지 정상 처리가 되면 수동 커밋을 한다.
       중간에 문제가 생기면 롤백으로 작업 이전으로 돌아감.

COMMIT : 모든 작업들을 정상적으로 처리하겠다고 확정하는 명령어

ROLLBACK : 마지막 커밋 지점으로 돌아감

데이터 무결성 제약조건
 - 테이블에 부적절한 자료가 입력되는 것을 방지하는 것
       테이블 생성시 각 컬럼에 대해 정의하는 여러가지 규칙
 1) NOT NULL : NULL을 허용하지 않음.
 2) UNIQUE : 중복을 허용하지 않음(유일한 값)
 3) PRIMARY KEY : NOT NULL + UNIQUE
 4) FOREIGN KEY : 참조되는 테이블의 컬럼에 같은 값이 존재하면 허용
		    기본키에 있는 데이터만 외래키가 있는 테이블에 입력 가능
		    외래키를 지정한 테이블에 값을 넣으려고 시도하면
		        기본키에 그 값이 있는지 확인하고 있으면 허용 없으면 에러
 5) CHECK : 저장 가능한 데이터 값의 범위나 조건을 지정하여 설정한 값만 허용

제약조건 확인하기
 - USER_CONSTRAINTS 데이터 딕셔너리로 내가 만든 제약조건의 정보를 조회
    · OWNER : 제약조건을 소유한 사용자명
    · CONSTRAINT_NAME : 제약조건 명
    · CONSTRAINT_TYPE : 제약조건 타입
	1) P : PRIMARY KEY
	2) R : FOREIGN KEY
	3) U : UNIQUE
	4) C : CHECK, NOT NULL
    · TABLE_NAME : 제약조건이 속한 테이블명
    · SEARCH_CONDITION : CHECK 조건일 경우 어떤 내용이 조건으로 사용되었는지?
    · R_CONSTRAINT_NAME : FOREIGN KEY인 경우 어떤 PRAMARY KEY를 참조했는지?
	ex) SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE
		FROM USER_CONSTRAINTS;
	     SELECT * FROM USER_CONSTRAINTS;

CONSTRAINT : 제약조건을 주는 키워드

칼럼 레벨 제약조건 설정하기
 - 칼럼 레벨로 제약조건 이름을 명시해서 제약조건 설정
       이 때 생긴 이름은 인덱스라고 부르며 검색할 때 검색키로 사용해서 검색 속도를 향상
        칼럼명 타입 CONSTRAINT 제약조건명 제약조건
 - 칼럼을 생성할 때 제약조건을 지정
       테이블 생성시 마지막에 쓰는건 테이블 레벨 제약조건
 - 따로 제약조건의 이름을 명시하지 않으면 오라클에서 자동으로 만들어준다.
 - 제약조건 이름 양식 
       테이블명_칼럼명_제약조건타입
 - NOT NULL은 칼럼 레벨 방식의 제약조건만 가능하다.

PRIMARY KEY : NOT NULL 제약조건과 UNIQUE 제약조건을 모두 갖고 있는 제약조건
		즉, 데이터들끼리의 유일성을 보장하는 칼럼에 설정
		테이블당 한개만 설정이 가능하다.
		단, 칼럼 두 개 이상을 하나로 묶어서 하나처럼 설정은 가능 = 복합키
		    이 경우 중복을 막을 때 두 컬럼이 모두 같은게 있으면 막는다.

FOREIGN KEY : 기본키에 존재하는 데이터만 외래키가 있는 테이블에 입력할 수 있다.
		부모테이블은 자식의 데이터나 테이블이 삭제된다고 영향을 받지 않는다.
		참조하는 데이터 칼럼과 데이터 타입이 "반드시" 일치해야 한다.
		참조할수 있는 컬럼은 기본키 or UNIQUE만 가능하다.
		외래키는 기본키

CASCADE : PARENT(기본키) 삭제 시 CHILD(외래키)도 같이 삭제(사용을 지양)
SET NULL : PARENT 삭제 시 CHILD의 해당 필드를 NULL로 UPDATE
SET DEFAULT : PARENT 삭제 시 CHILD의 해당 필드를 DEFAULT 값으로 UPDATE
RESTRICT : CHILD 테이블에 PK 값이 없는 경우만 PARENT 삭제
NO ACTION : 참조 무결성 제약조건을 위배하는 액션은 불가

COMPOSITE KEY : 여러 열을 조합하여 기본키 역할을 할 수 있게 만든 키(복합키)
	               하나의 열만으로 행을 식별하는 것이 불가능하여 여러 열 값을
		   함께 사용해야 각 행이 유일한 데이터로서 가치를 지닌다.
		   이 경우 외래키로 참조할 때 복합키에 조합된 열 중 하나를 UNIQUE로 만들어서 참조?

CHECK : 입력되는 값을 체크하여 설정된 값 이외의 값이 들어오면 
	  오류 메시지와 함께 명령이 수행되지 못하게 하는 것.
	  조건으로 데이터의 값의 범위나 특정 패턴의 숫자나 문자 값을 설정할 수 있다.
	  ex) 컬럼명 number CONSTRAINT 테이블명_컬럼명_이름 CHECK(컬럼명 BETWEEN 500 AND 5000)
	       컬럼명 varcher2 CONSTRAINT 테이블명_컬럼명_이름 CHECK(컬럼명 IN('M','m','F','f')

DEFAULT : 아무런 값을 입력하지 않았을 때 디폴트로 값이 입력된다.
	      NULL도 값이라서 NULL을 넣으면 디폴트 값이 아닌 NULL이 들어간다.
	      컬럼명 varcher2 DEFAULT '없음'

테이블 레벨 방식의 제약조건
 - 컬럼을 모두 정의하고 나서 테이블 정의를 마무리 짓기 전에
       따로 생성된 컬럼들에 대한 제약조건을 한꺼번에 지정하는 것
       [CONSTRAINT 테이블명_컬럼명_제약조건타입] 제약조건
	                  생략 가능

 - 복합키로 기본키를 지정할 경우
       2개 이상의 컬럼이 하나의 기본키를 구성하는 경우
       복합키 형태로 제약 조건을 지정할 경우 컬럼 레벨 형식으로는 불가능
       반드시 테이블 레벨 방식을 사용
       CONSTRAINT 인덱스 PRIMARY KEY(컬럼명1, 컬럼명2, ... )
 
 - ALTER TABLE로 제약조건을 추가할 때
       테이블의 정의가 완료되어서 이미 테이블의 구조가 결정된 후에
       나중에 테이블에 제약 조건을 추가하고자 할 때 테이블 레벨 방식을 사용
       (왠만하면 테이블을 정의할 때 제약조건을 정의하자.)

PRIMARY KEY로 만든 column명 조회하기
 - SELECT constraint_name, table_name, column_name FROM USER_CONS_COLUMNS;

SEQUENCE : 번호표(인덱스) 붙이는 담당자
	       레코드의 특정 컬럼에 대해 자동으로 인덱스를 부여할 수 있음
	       NEXTVAL을 사용하여 다음 인덱스로 넘어감
	       한 번 넘어간 인덱스는 이전 인덱스로 돌아올 수 없다.
	       중복 인덱스가 부여되지 않으므로 UNIQUE 성질을 지킬 수 있다.
	       - 생성
	           · CREATE SYQUENCE 시퀀스명;
	       - 사용
	           · 시퀀스명.NEXTVAL을 기본키로 지정된 컬럼에 넣는다.
	       - 삭제
	           · DROP SEQUENCE 시퀀스명;
	       - 현재 유저의 모든 시퀀스에 대한 정보 조회
	           · SELECT * FROM USER_SEQUENCES;
	       - 시퀀스 현재값 조회
	           · SELECT 시퀀스명.CURRVAL FROM DUAL;
		     DUAL 테이블이 아닌 사용하고 있는 테이블을 쓰면
		     값이 행의 갯수만큼 여러번 출력
		     DUAL 테이블 : 산술연산의 결과를 한줄로 얻기 위한 오라클 기본 제공 테이블
	       - 시퀀스 옵션
	           · START WITH n : n부터 시작
	           · INCREMENT BY n : n씩 증가(음수면 감소, DEFAULT 1)
	           · MAXVALUE n : 최대값을 n으로 지정
	           · NOMAXVALUE : 최대값 없음(무한대로 증가, 기본설정)
	           · MINVALUE n : 최소값을 n으로 지정
	           · NOMINVALUE : 최소값 없음(무한대로 감소, 기본설정)
	           · CYCLE : 최대값/최소값 도달시 순환(다시 최대값/최소값부터 시작)
	           · NOCYCLE : 순환하지 않음(도달하면 더 이상 NEXTVAL을 사용할 수 없음, 기본설정)
	           · CACHE : 미리 메모리에 생성 해두겠다, DEFAULT 20
	           · NOCACHE : 미리 메모리에 생성해두지 않겠다.
	           ※ ','로 구분하지 않고 그냥 띄워쓰기로 구분

제약조건 변경하기
 - 이미 존재하는 테이블에 제약조건을 추가, 삭제, 변경하는 경우
      ALTER TABLE문을 사용
 - 추가
   · ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 PRIMARY KEY(칼럼명);
 - 삭제
   · ALTER TABLE 테이블명 DROP PRIMARY KEY;
        기본키만 가능하다.
   · ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명;
 - NOT NULL은 MODIFY로 변경
   · 이미 NULL이 추가되어 있다고 생각해서 NOT NULL로 변경하기 때문에  
   · 추가 : ALTER TABLE 테이블명 MODIFY 칼럼명 CONSTRAINT 제약조건명 NOT NULL;
   · 삭제 : 삭제는 동일함
	 ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명;
 - UNIQUE 제약조건은 중복을 막아서 유일한 값이 되게 한다.
      단, NULL 값은 예외로 함

제약 조건의 활성화/비활성화
 - 업무를 수행하는 과정에서 제약조건 때문에 작업이 진행되지 못하는 경우
       제약조건을 삭제해 버리면 데이터 무결성을 보장받지 못함
       이런 경우 제약조건을 비활성화시킴으로서 제약조건 사용을 보류시킴

 - 제약조건 비활성화
   · 제약조건을 삭제하지 않고 비활성화하여 사용을 잠시 보류
      ex) 외래키가 참조하고 있는 기본키의 데이터를 삭제해야 할 경우
              외래키를 비활성화한 뒤 기본키를 삭제
	  ALTER TABLE 테이블명 DISABLE CONSTRAINT 제약조건명;

 - 제약조건 활성화
   · 사용을 잠시 보류해 놓은 제약조건을 깨움
      ex) ALTER TABLE 테이블명 ENABLE CONSTRAINT 제약조건명;

 - CASCADE 옵션
   · 부모테이블과 자식테이블 간의 참조 설정이 되어 있을 때
       부모테이블의 제약조건을 비활성화하면 이를 참조하고 있는
       자식테이블의 제약조건도 같이 비활성화
       ALTER TABLE 부모테이블 DISABLE PRIMARY KEY CASCADE;

   · 부모테이블의 제약조건을 삭제하면 이를 참조하고 있는
       자식테이블의 제약조건도 같이 삭제
       (그래서 사용을 지양함)

   · 강제로 참조관계를 끊고 부모 테이블을 삭제
        DROP TABLE 부모테이블명 CASCADE CONSTRAINTS;

   · 강제로 참조관계를 끊기
        ALTER TABLE 테이블명 DROP 제약조건 CASCADE;

외래키를 만들면서 옵션을 부여
 - CASCADE
   · ALTER TABLE 부모테이블명 DISABLE CONSTRAINT 제약조건명 CASCADE;
        기본키가 disable되면 외래키도 disable된다.
        다시 활성화하는 경우 기본키와 외래키 각각 활성화 한다
        ALTER TABLE 부모테이블명 ENABLE CONSTRAINT 제약조건명;
        ALTER TABLE 자식테이블명 ENABLE CONSTRAINT 제약조건명;
        기본키부터 활성화하고 외래키를 활성화하기

   · 부모테이블의 데이터를 지우면 그걸 참조하는 자식테이블의 데이터도 지워지는 것
        ALTER TABLE 자식테이블명 ADD CONSTRAINT 제약조건명 FOREIGN KEY(칼럼명)
	REFERENCES 부모테이블(칼럼명) ON DELETE CASCADE;
	(데이터 손실 우려가 있어서 사용을 지양한다.)

 - SET NULL
   · 부모테이블의 데이터를 지우면 그걸 참조하는 자식테이블의 데이터는 NULL이 되는 것
        ALTER TABLE 자식테이블명 ADD CONSTRAINT 제약조건명 FOREIGN KEY(칼럼명)
	REFERENCES 부모테이블(칼럼명) ON DELETE SET NULL;

자동으로 시스템이 부여한 제약조건명 얻기
 - SELECT * FROM USER_CON_COLUMNS WHERE TABLE_NAME = '테이블명(대문자로)';
   = CONSTRAINT가 임의로 부여된 제약조건명

JOIN
 - 2개 이상의 참조 관계인 테이블에 흩어져 있는 데이터들을 합치는 작업
      부모테이블(기본키)과 자식테이블(외래키)로 나눔 
      보통 부모테이블과 자식테이블은 1:N 관계
      하지만 부모와 자식은 상대적이라서 자식테이블이 다른 테이블의 부모테이블이 될 수도 있음

 - 참조 관계가 아니어도 JOIN 할 수 있음

Cartesian Product
 - 곱집합

 - 모든 경우의 수를 만들어서 가져오는 것
      A테이블의 row x B테이블의 row

 - ANSI JOIN에서는 CROSS JOIN이라 부름

 - JOIN 중 WHERE 절의 조건이 잘못 되었거나 없을 경우 발생

 - 사용하는 이유
      1) 데이터를 복제해서 원본 테이블을 반복해서 읽는 것을 피하기 위해 
      2) 실수로 JOIN 조건 컬럼 중 일부를 빼먹는 경우 발생
      3) 테스트를 위해 댜랑의 데이터가 필요할 때 이용
      단, 의도하지 않은 Cartesian Product는 데이터에 부하가 걸릴 수 있어서(너무 많아서)
          위험하므로 JOIN 조건절에 반드시 해당 테이블을 사용하는 조건들이 있는지 확인

테이블에 별칭(Alias) 붙이기
 - SELECT * FROM A테이블명 a, B테이블명 b WHERE a.칼럼명 = b.칼럼명;
      FROM에서 테이블명을 적고 별칭을 적어주면
      그 때부터 테이블명 대신 별칭으로 사용
      단, 원래 테이블명을 사용하면 오류 발생

모호성
 - 두 개의 테이블이 같은 이름의 칼럼을 가지고 있는 경우
       어느 테이블의 칼럼인지 알 수 없는 모호성을 가지기 때문에
       별칭이나 테이블명을 칼럼명 앞에 명시하여 모호성을 제거

ANSI JOIN
 - 국제 표준 SQL 방식
      DB 종류에 상관없이 먹히는 JOIN

 - INNER JOIN
   · ON : WHERE 대신 사용
   · USING : JOIN하는 두 테이블의 칼럼명이 같을 경우 사용
	      단, USING 사용시 SELECT절에 칼럼명 앞에 별칭을 붙이면 오류 발생

 - OUTER JOIN
   · LEFT / RIGHT / FULL

INNER JOIN(ANSI)
 - 관계가 있는 데이터끼리만 합침

 - 조건절에서 '=' 연산자만 사용

 - 구조 : SELECT * FROM A테이블명 [INNER] JOIN B테이블명 
	    ON A.칼럼명 = B.칼럼명;

 - JOIN 조건에서 값이 일치하는 데이터만 JOIN
                            일치하지 않은 데이터는 누락

 - 사용 예시
   · 테이블 3개를 JOIN
        SELECT * FROM A테이블 a JOIN B테이블 b ON a.칼럼명 = b.칼럼명
			      JOIN C테이블 c ON a칼럼명 = c.칼럼명;
   · 조건이 2개 이상인 경우
        SELECT * FROM A테이블 a JOIN B테이블 b 
	ON a.칼럼명 = 100 AND a.칼럼명 = b.칼럼명;

 - EQUI JOIN(ORACLE)
   · 가장 많이 사용되는 조인
   · SELECT * FROM A테이블명, B테이블명 
	WHERE A.칼럼명 = B.칼럼명;

 - NON-EQUI JOIN(ORACLE)
   · 사용 빈도가 매우 낮음
   · '='을 제외한 연산자를 사용
         BETWEEN AND, IS NULL, IS NOT NULL, IN, NOT IN
         >, >=, <, <=, <>

OUTER JOIN(ANSI)
 - OUTER : 공통으로 가지고 있지 않은 데이터

 - INNER JOIN과 반대 개념
      기준이 되는 테이블의 OUTER 데이터까지 모두 출력
      OUTER에는 NULL이 들어감

 - 사용 예시
   · 작가와 책 이름을 JOIN 할 때 책을 출간하지 않은 작가도 출력하는 경우
   · 지도교수가 결정되지 않은 학생의 이름이나
     담당학생이 결정되지 않은 교수의 이름까지 출력하는 경우

 - 장단점
   · 장점 : 모든 데이터를 다 출력
   · 단점 : OUTER가 많으면 그만큼 NULL이 많아서
	    DB 성능에 아주 나쁜 영향을 줄 수 있으므로 신중해야 함

 - LEFT/RIGHT/FULL OUTER JOIN
   · LEFT : 왼쪽의 테이블을 기준으로 공통인 데이터를 JOIN
	    단, 왼쪽의 OUTER도 NULL을 넣어서 출력
   · RIGHT : LEFT와 반대되는 개념
   ※ LEFT와 RIGHT를 같이 사용하면 가독성이 떨어지고 헷갈리기 때문에
         보통은 LEFT로 통일해서 사용함
   · FULL : 양쪽의 모든 데이터를 출력
	     OUTER에는 NULL을 넣어서 출력

 - SELECT * FROM A테이블 a (LEFT/RIGHT/FULL) OUTER JOIN B테이블 b
       ON a.칼럼명 = b.칼럼명;

 - Oracle의 경우 (+)를 사용
      기준이 되는 테이블 반대쪽에 (+)를 사용
      (+)를 빼먹으면 INNER JOIN이 된다.
      SELECT * FROM A테이블 a, B테이블 b WHERE a.칼럼명 = b.칼럼명(+);

SELF JOIN
 - 하나의 테이블로 JOIN
      JOIN의 대상이 나와 또 다른 나
 
 - 모호성을 제거하기 위해 테이블 하나에 서로 다른 별칭을 반드시 명시해야 함
      SELECT * FROM A테이블 a JOIN A테이블 A ON a.칼럼명 = A.칼럼명;

SELECT 쿼리 수행 순서
 - SELECT ⑤
    FROM ①
    WHERE ②
    GROUP BY ③
    HAVING ④
    ORDER BY ⑥

 ① FROM : 적혀있는 테이블들이 존재하는지 확인
	      권한이 있는지 확인, 권한이 없을 경우 DB가 Semantic Error를 발생

 ② WHERE : 어떤 조건들이 있는지 확인하고
	       테이블에서 조건에 맞는 로우들을 가지고 옴

 ③ GROUP BY : 가지고 온 로우들을 어떤 방식으로 GROUP BY 할 것인지 확인

 ④ HAVING : GROUP BY 한것 중에서 버려야할 데이터들이 있는지 확인

 ⑤ SELECT : 내가 가져온 로우 중 어떤 컬럼들을 출력해야 하는지 확인
                   일단 다 가져오고 난 다음에 SELECT절을 확인하기 때문에
	       SELECT * FROM과 SELECT에서 컬럼 1개만 가져온거랑
	       사실상 드는 IO비용은 같다.
	       단, SELECT절에 있는 컬럼들이 모두 인덱스에 담겨져 있다면 다른 문제

 ⑥ ORDER BY : 사용할 로우들과 필요한 컬럼들까지 다 가지고 왔을 때 정렬
	           SELECT절에서 컬럼에 별칭(Alias)을 지정해 놨을 경우

 ※ 이전 순서에서 Alias를 지정하면 이후 순서부터는 Alias를 사용할 수 있다.

 Semantic Error : SELECE 권한이 없는데 SELECT문을 사용하거나
	          UPDATE 권한이 없는데 UPDATE문을 사용하는 경우
 Syntax Error : 오타를 치거나, 쉼표가 있어야 하는데 쉼표가 없는 경우
	    
서브쿼리(부조회)
 - 쿼리 안에 있는 또 다른 쿼리
      밖에 있는 쿼리를 메인 쿼리,
      안에 있는 쿼리를 서브 쿼리라고 함

 - ( )안에 작성하면 ( )안에 있는 식부터 처리한다.

 - DML문 모두에서 사용할 수 있음

 - Nesting : 서브쿼리 안에 서브쿼리가 들어가는 것
	      메모리가 허용하는 한 무제한으로 중첩 가능
 
 - 서브쿼리에서 SELECT 하지 않은 컬럼은 메인쿼리에서 사용할 수 없음

 - 서브쿼리의 결과를 가지고 메인쿼리를 실행해서 결과를 얻음

 - 서브쿼리를 쓰면 무조건 성능에 안좋다?
      서브쿼리로 짜든, JOIN으로 풀어서 짜든 
      어떤 것이 유리한지 옵티마이저가 알아서 판단해서 
      실행 계획을 작성하기 때문에 성능과는 무관하다.

 - 서브쿼리를 반드시 쓰면 안되는 경우
      하나의 테이블을 메인쿼리와 서브쿼리에서 여러번 쓰는 경우
      성능이 굉장히 떨어짐
      
WHERE절에 사용하는 중첩 서브쿼리
 - 단일 행 서브쿼리
   · ( ) 결과가 오직 하나의 행을 반환 
   · 메인쿼리의 WHERE절에서는 단일 행 비교 연산자를 사용해야 함
        ※ 단일 행 비교 연산자 : =, >, >=, <, <=, <>

 - 다중 행 서브쿼리
   · ( ) 결과가 여러 개의 행으로 반환
   · 반드시 다중 행 연산자와 함께 사용해야 함
        ※ 다중 행 연산자 : IN, ANY, SOME, ALL, EXISTS
	IN : 서브쿼리 결과와 같은 값을 찾음
	ANY(SOME)
	 - 만족하는 값이 하나만 있으면 된다.(OR)
                 · 1000 > ANY (500, 1000, 2000)
	       1000 > 500 OR 1000 > 1000 OR 1000 > 2000과 동일
	           즉, 나올수 있는 모든 조건에 OR 연산을 수행한 것과 동일
	       ANY 값에 1000보다 작은 500이 있으므로 TRUE
                 · = ANY(SOME) : 서브쿼리 결과 중에서 하나라도 만족하는 값이 있으면 리턴(IN과 동일)
                 · > ANY(SOME) : 서브쿼리 결과 중에서 최대값을 반환
                 · < ANY(SOME) : 서브쿼리 결과 중에서 최대값을 반환

	ALL
             - 모든 값을 만족해야 한다.(AND)
                 · 1000 > ALL (500, 1000, 2000)
	       1000 > 500 AND 1000 > 1000 AND 1000 > 2000과 동일
	          즉, 나올 수 있는 모든 조건에 AND 연산을 수행한 것과 동일
	          1000이 ALL의 모든 값보다 작아야하므로 FALSE
                 · > ALL : 서브쿼리 결과 중에서 최대값을 반환
                 · < ALL : 서브쿼리 결과 중에서 최소값을 반환
	EXISTS : 서브쿼리의 값이 있을 경우 메인쿼리를 수행
	NOT EXISTS : 서브쿼리의 값이 없을 경우 메인쿼리를 수행

 - 서브쿼리로 테이블 생성하기
   · 제약조건은 복제되지 않음
   · 이미 존재하는 테이블과 동일한 구조와 내용을 갖는 새로운 테이블 생성
	CREATE TABLE 복제테이블명 AS SELECT * FROM 원본테이블명;
   · 이미 존재하는 테이블과 동일한 구조와 필요한 컬럼만 갖는 새로운 테이블 생성
	CREATE TABLE 복제테이블명 AS SELECT 필요한컬럼명 FROM 원본테이블명;
   · 조건에 일치하는 내용만 갖는 새로운 테이블 생성
	CREATE TABLE 복제테이블명 AS SELECT * 원본테이블명 WHERE 조건;
	    조건을 1=0으로 주면 구조만 동일한 빈 테이블이 생성

 - 서브쿼리로 데이터 삽입하기
   · 테이블 내용을 복사할 때 구조가 같은데 컬럼명이 다르면 삽입이 가능함

   · 구조 순서가 다르거나 갯수가 다르고 같은 타입의 컬럼이 있을 경우
         컬럼을 명시해주면 복사가 가능하다.
         INSERT INTO dept06(deptno, dname1, loc1) SELECT * FROM dept;
         INSERT INTO dept06 SELECT deptno, dname1, loc1 FROM dept; --위와 같음

 - 서브쿼리로 데이터 변경하기
   · UPDATE dept03 
         SET loc = (SELECT loc FROM dept03 WHERE deptno=40) 
	  WHERE deptno = 20;

 - 서브쿼리로 데이터 삭제하기
       DELETE emp02 
	WHERE deptno = (SELECT deptno FROM dept WHERE dname = '영업부');

View
 - 물리적인 테이블(Table)을 근거로 논리적인 가상 테이블(View)을 정의
         창문을 통해 보고싶은 부분(쿼리문)을 View로 만드는 것
 - DB의 SELECT문을 저장한 OBJECT
 - 쿼리문에서 테이블처럼 사용
 - 뷰를 사용하는 이유
        1) 긴 쿼리문이나 자주 사용하는 쿼리문을 View로 정의하면 접근을 단순화시킬 수 있음
                쿼리문을 View에 저장
        2) 보안에 유리함
                테이블의 일부 칼럼만 View로 만들어서 일부 데이터만 보여줄 수 있음
                    사용자에게 테이블을 보여주는 것이 아니라 View를 보여주는 것

 - View의 내부 구조
       desc user_views의 TEXT 칼럼에 View가 처리하는 쿼리문이 들어있음
 
 - View 정의하기
       테이블 복사와 같음
       CREATE VIEW 뷰이름 AS 쿼리문;

 - View 제거하기
       DROP VIEW 뷰이름;

 - View의 동작 순서
       1) 사용자가 쿼리문을 수행
              SELECT * FROM 뷰이름;
       2) View의 TEXT 칼럼안에 있는 자료인 SELECT문을 수행
       3) SELECT문을 통해 테이블의 데이터가 조회
       4) 조회에 의한 결과 수행
       5) 1번으로 결과를 리턴

 - View에 데이터 추가하기
       INSERT INTO 뷰이름 VALUES();
 
 - View에 있는 데이터 수정하기
       UPDATE 뷰이름 SET 바꿀내용 WHERE 조건

 - View에 있는 데이터 삭제하기
       DELETE 뷰이름 WHERE 조건
           조건을 주지 않으면 뷰의 모든 데이터 삭제

 ※ View에서 데이터를 추가, 수정, 삭제하면 물리적인 데이터에도 적용된다.
        View 생성시 근거로 사용된 테이블의 자료도 바뀌는 것

 - OP REPLACE
       View가 존재하지 않으면 생성하고 존재하면 수정함
       CREATE OR REPLACE VIEW 뷰이름 AS 쿼리문;

 - FORCE
       테이블이 없어도 View를 만드는 것
           단, 테이블이 생성되지 않으면 생성한 View도 사용할 수 없음
       거의 사용하지 않음
       CREATE OR REPLACE FORCE VIEW 뷰이름 AS 쿼리문;

 - NOFORCE
       테이블이 있어야 View를 만드는 것
       변경하지 않으면 Default(기본 설정)

 - WITH CHECK OPTION
       테이블 중 조건에 만족하는 ROW만으로 구성된 View를 생성
       WHERE절에 있는 칼럼의 값의 수정을 막음
       예시
           CREATE VIEW 뷰이름 
           AS SELECT * FROM 테이블명 
           WHERE deptno = 30 WITH CHECK OPTION;
               이 후에 deptno 수정시 오류 발생

 - WITH READ ONLY
       모든 칼럼을 읽기 전용으로 변경
           수정, 추가, 삭제가 불가능
       예시
           CREATE OR REPLACE VIEW 뷰이름
           AS SELECT * FROM 테이블명
           WHERE 조건 WITH READ ONLY;

INLINE VIEW 
 - SQL문 내부에 View를 정의하고 이를 테이블처럼 사용하는 것
 - FROM절에 쓰이는 서브 쿼리
 - 다른 쿼리에서 사용할 필요 없이 해당 SQL에서만 필요한 View일 경우
       View처럼 따로 Object를 생성하지 않고 SQL 안에 직접 기술해서 쓰는 일회성 View
 - SELECT * FROM (SELECT * FROM 테이블명) 별칭;
       별칭(Alias)는 경우에 따라 지정해주기

 - View로 View를 만들 수 있다.
       CREATE OR REPLACE VIEW 뷰이름 
       AS SELECT * FROM 테이블명
       ORDER BY 칼럼명;
       
       CREATE OR REPLACE VIEW 뷰이름2
       AS SELECT * FROM 뷰이름
       WHERE 조건;

ROWNUM
 - INSERT문을 이용하여 입력하면 자동으로 입력한 순서에 따라 1씩 증가하면서 값이 지정
 - 데이터가 입력된 시점에서 결정되는 ROWNUM 칼럼의 값은 바뀌지 않음
 - ROWID와 다르다.       
       ROWID는 ROW가 가진 고유의 값

CEIL
 - 값을 나눴을 때 소수점이 발생하면 【무조건 올려줌】
       SELECT CEIL(10/3) FROM DUAL;
           결과는 3.333…이지만 CEIL이라서 4가 나옴

ROLLUP
 - 그룹별 Sub Total의 개념
 - GROUP BY를 한 결과를 가지고 롤업하면 GROUP BY를 한 애들의 총합을 구할 수 있음
       여러 칼럼을 ROLLUP할 경우 ROLLUP(칼럼명1, 칼럼명2)를 하게 되면
       GROUP BY 칼럼명1, 칼럼명2 + GROUP BY 칼럼명1 + 총합계
           어떤 칼럼이 앞에 오느냐에 따라 결과가 달라짐
       칼럼이 3개일 경우
       GROUP BY 칼럼명1, 칼럼명2, 칼럼명3 + GROUP BY 칼럼명1, 칼럼명2
       + GROUP BY 칼럼명1 + 총합계
       만약 GROUP BY ROLLUP으로 여러개를 묶었지만 필요 없는 총계들이 생길 경우
           필요없는 총계들끼리 묶어준다.

실행 내역 확인하기
 - SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(null, null, 'ALLSTATS LAST'));

ROLLUP
 - GROUP BY의 확장된 형태
       GROUP BY별 Sub Total의 개념 
 - 복잡한 SQL문을 짧게 만들고 해당 데이터들을 반복적으로 읽는 것을 최소화해서 속도가 빠름
 - 계층적 분류를 포함하고 있는 데이터의 집계에 적합
 - 어떤 칼럼이 먼저 오느냐에 따라 결과가 달라진다.
 - 지정된 칼럼들은 소계의 기준이 된다.
       칼럼들의 수를 n이라고 하면 n+1의 소계 그룹이 생성
       예시
           칼럼이 3개일 경우
           ROLLUP(칼럼1,칼럼2,칼럼3) 
           + ROLLUP(칼럼1,칼럼2) 
           + ROLLUP(칼럼1) 
           + 총합계

 - GROUP BY의 원리
       ROLLUP의 인자로 들어온 칼럼을 오른쪽부터 하나씩 빼면서 GROUP을 만든다.
       ( )의 의미는 GROUP이 없는 즉, 전체에 대한 결과를 출력한다는 뜻
       괄호로 묶여져 있는 칼럼은 하나로 본다는 뜻
       ROLLUP 이전에 일반 칼럼과 GROUP BY 한다면, 일반 칼럼은 끝까지 남는다.
           GROUP BY ROLLUP(A, B, C)
               1) A B C
               2) A B
               3) A
               4) ( )
           GROUP BY ROLLUP(A, (B, C))
               1) A (B C)
               2) A
               3) ( )
           GROUP BY A, ROLLUP((B, C))
               1) A (B C)
               2) A  

 - 참고글 : https://myjamong.tistory.com/191

CUBE
 - 각 그룹의 모든 경우의 수에 대한 소계와 총계를 구함
 - ROLLUP과 CUBE의 차이점은
       ROLLUP
           GROUP BY ROLLUP(칼럼명A, 칼럼명B)
               대상 데이터에 대해, 칼럼A와 B에 따라
               1) 칼럼(A, B)에 따른 소계를 자동 계산하여 결과 테이블 중간에 출력
               2) 전체 총계를 자동 계산하여 결과 테이블 가장 아래에 출력
       CUBE
           GROUP BY CUBE(칼럼명A, 칼럼명B)
               대상 데이터에 대해, 칼럼A와 B에 따라
               1) 칼럼(A, B)에 따른 소계를 자동 계산하여 결과테이블 중간에 출력
               2) 전체 총계를 자동 계산하여 결과 테이블의 가장 윗행에 출력
               3) 칼럼 A별 소계, 칼럼 B별 소계를 자동 계산하여 결과 테이블 가장 윗행에 출력

       ※ ROLLUP은 A의 소계만 나오고 CUBE는 A와 B의 소계가 나온다.

SEQUENCE
 - 일련번호
       중복되면 안되고 계속해서 번호가 증가
 - 테이블 내의 유일한 숫자를 자동으로 생성하는 자동 번호 발생기
       기본키로 사용하면 사용자의 부담이 줄어든다.
           ex) CREATE TABLE 테이블명(
	        test number(3));
	        INSERT INTO 테이블명 VALUES(시퀀스명.NEXTVAL);

 - 시퀀스 생성하기
       CREATE SEQUENCE 시퀀스명
           [START WITH n] : 시작하는 숫자,
		          DEFAULT는 1
           [INCREMENT BY n] : 증가하는 숫자,
			 DEFAULT는 1
           [MAXVALUE n | NOMAXVALUE] : 최대 숫자
				     DEFAULT는 NOMAXVALUE
           [MINVALUE n | NOMINVALUE] : 최소 숫자
				   DEFAULT는 NOMINVALUE
           [CYCLE | NOCYCLE] : 최대가 되면 최소로,
			 DEFAULT는 NOCYCLE
           [CACHE n | NOCACHE] : 메모리에 시퀀스 값을 미리 할당하는지 안하는지,
			      시퀀스로 번호를 생성할 때마다 번호를 계산해서 뽑게 되면
			          시간이 많이 걸리기 때문에 
                                              CACHE 20하면 번호 20개를 미리 뽑아놓으라는 의미
           ※ ','로 구분하지 않음

 - 시퀀스 삭제하기
       DROP SEQUENCE 시퀀스명;

 - 시퀀스 수정하기
       ALTER SEQUENCE 시퀀스명 
           수정할 내용
               ex) INCREMENT BY 20
                    CYCLE
       단, 시작 위치는 수정할 수 없다.
       INCREMENT BY를 수정하면 시작 위치가 1로 바뀐다.

 - NEXTVAL
       현재 시퀀스의 다음 값 구하기
       다음 포인터가 어디를 가르키는지?
       주로 INSERT문에 많이 사용된다.

 - CURRVAL
       현재 시퀀스의 값 구하기
       현재 포인터가 어디를 가르키는지?
       시퀀스를 생성하고 NEXTVAL을 하지 않고 CURRVAL을 하면 
           시작 위치에서 한 번도 이동하지 않아서 포인터 위치를 알 수 없으므로 오류 발생

인덱스
 - SQL 명령문의 처리 속도를 향상시키기 위해 칼럼에 대해 생성하는 오라클 객체
 - 오라클에서 인덱스의 내부 구조는 보통 B(2진) 트리 형식으로 구성
 - 인덱스가 생성되면 테이블과 매핑된 또 다른 테이블이 하나 생성된다.
       인덱스에서 먼저 데이터들을 찾은 다음 
       매핑된 테이블로 가서 나머지 데이터들을 꺼내오는 방식
 - 장점
       정렬, 검색 속도가 빨라짐
       시스템에 걸리는 부하를 줄여서 시스템 전체 성능을 향상
 - 단점
       인덱스를 위한 추가적인 공간이 필요
       인덱스를 생성하는데 시간이 걸림
       데이터 변경 작업이 자주 일어날 경우 오히려 성능이 저하된다.
                   (INSERT, UPDATE, DELETE)

 - 인덱스를 사용하면 효율적인 경우
       1) 테이블에 행의 수가 많은 경우
       2) WHERE절에 칼럼이 많이 사용되는 경우
       3) 검색 결과가 전체 데이터의 2~4%일 경우
       4) JOIN에 자주 사용되는 칼럼이나 NULL을 포함하는 칼럼이 많은 경우
       5) ORDER BY절에 자주 등장하는 칼럼을 인덱스로 지정
               인덱스는 정렬이 되서 저장되어 있기 때문에 
                따로 정렬을 할 필요가 없이 출력하면 된다.

 - 인덱스를 사용하면 비효율적인 경우
       1) 테이블에 행의 수가 적은 경우
       2) WHERE절에 해당 칼럼이 자주 사용되지 않는 경우
       3) 전체 결과가 전체 데이터의 10 ~ 15% 이상일 경우
       4) 테이블에 DML 작업이 많은 경우

 - 인덱스 생성하기 
       CREATE INDEX 인덱스명 ON 테이블명(칼럼명);
           칼럼을 기준으로 2진 트리를 만드는 것
 
 - 인덱스 제거하기
       DROP INDEX 인덱스명;

 - 인덱스 수정하기

 - 인덱스 정보 조회
       user_ind_columns

 - 인덱스의 종류
       고유 인덱스 : 유일키처럼 유일한 값을 갖는 칼럼에 대개 인덱스를 생성
		    데이터가 중복되는 칼럼은 고유 인덱스로 만들 수 없음
		    CREATE UNIQUE INDEX 인덱스명 ON 테이블명(칼럼명)

       비고유 인덱스 : 중복된 데이터를 갖는 칼럼에 대해 인덱스를 생성
		       CREATE INDEX 인덱스명 ON 테이블명(칼럼명)

       ※ 인덱스를 만든 칼럼으로 또 인덱스를 만들 순 없다.

       결합 인덱스 : 두개 이상의 칼럼으로 인덱스를 구성
		    CREATE INDEX 인덱스명 ON 테이블명(칼럼명1, 칼럼명2);
		        결합 인덱스이자 비 고유 인덱스
 		    이미 고유/비고유 인덱스로 만든 칼럼을 사용해서 결합 인덱스를 만들 수 있음
		        반대로 결합 인덱스로 만든 칼럼들로 고유/비고유 인덱스를 만들 수 있음
                            결합하는 칼럼의 순서가 중요
		         WHERE절에서 equal 조건으로 많이 쓰는 칼럼들이 앞으로 오는게 효율적
		         분별력이 높은 칼럼이 앞으로 오는게 효율적

       함수 기반 인덱스 : 검색 조건으로 WHERE sal = 300이 아니라
		           WHERE sal * 12 = 3600과 같이
		           WHERE절에 산술 표현 또는 함수를 사용하는 경우 인덱스를 타지 못함
                                       테이블명(칼럼명) 한거에 계산식을 하면 인덱스가 적용 안됨
		           SUBSTR도 마찬가지
		           이러한 경우 수식이나 함수를 적용하여 인덱스를 만들 수 있다.
		           CREATE INDEX 인덱스명 ON 테이블명(칼럼명 * 12);

 - 인덱스 수정하기
       ALTER INDEX 인덱스명 REBUILD;
           구조를 수정하는게 아님
           인덱스가 생성된 후 테이블에 새로운 행이 추가, 삭제, 변경되는 경우
           이진 트리를 다시 구성하는 것
           인덱스로 만든 칼럼의 데이터를 재구축
		           
사용자 관리
 - 관리자 계정
       sys : 모든 권한
       system : 계정에 대한 모든 권한

 - 현재 접속한 사용자 이름 
       SHOW USER;

 - 사용자 생성
       CREATE USER 유저ID IDENTIFIED BY 유저PW;
		           
SET TIMING ON
 - 작업 시간을 보는 것

Oracle 11g express edition 제한 사항
 - 시스템에서 하나의 CPU 코어만 사용
 - 최대 1GB RAM 사용
 - 11.2에 최대 4GB 데이터, 11GB의 데이터 저장
 - 분할 된 개체
 - 문자셋 변경
 - 구체화 된 뷰 질의 재 작성

/*
 - SYSDATE : 년, 월, 일까지만 나옴
     SYSTIMESTAMP : 년, 월, 일, 시, 분, 초까지 나옴

 - order by는 항상 마지막에 적는다.

 - 제약조건이름도 중복이 안되니 확인하기

 - ERD 표에서 윗칸은 기본키

 - ROW_NUMBER : 로우에 순번을 매겨줌

 - ( )안에 작성하면 ( )안에 있는 식부터 처리한다.

*/
