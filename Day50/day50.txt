ROLLUP
 - GROUP BY의 확장된 형태
       GROUP BY별 Sub Total의 개념 
 - 복잡한 SQL문을 짧게 만들고 해당 데이터들을 반복적으로 읽는 것을 최소화해서 속도가 빠름
 - 계층적 분류를 포함하고 있는 데이터의 집계에 적합
 - 어떤 칼럼이 먼저 오느냐에 따라 결과가 달라진다.
 - 지정된 칼럼들은 소계의 기준이 된다.
       칼럼들의 수를 n이라고 하면 n+1의 소계 그룹이 생성
       예시
           칼럼이 3개일 경우
           ROLLUP(칼럼1,칼럼2,칼럼3) 
           + ROLLUP(칼럼1,칼럼2) 
           + ROLLUP(칼럼1) 
           + 총합계


 - GROUP BY의 원리
       ROLLUP의 인자로 들어온 칼럼을 오른쪽부터 하나씩 빼면서 GROUP을 만든다.
       ( )의 의미는 GROUP이 없는 즉, 전체에 대한 결과를 출력한다는 뜻
       괄호로 묶여져 있는 칼럼은 하나로 본다는 뜻
       ROLLUP 이전에 일반 칼럼과 GROUP BY 한다면, 일반 칼럼은 끝까지 남는다.
           GROUP BY ROLLUP(A, B, C)
               1) A B C
               2) A B
               3) A
               4) ( )
           GROUP BY ROLLUP(A, (B, C))
               1) A (B C)
               2) A
               3) ( )
           GROUP BY A, ROLLUP((B, C))
               1) A (B C)
               2) A  

 - 참고글 : https://myjamong.tistory.com/191

CUBE
 - 각 그룹의 모든 경우의 수에 대한 소계와 총계를 구함
 - ROLLUP과 CUBE의 차이점은
       ROLLUP
           GROUP BY ROLLUP(칼럼명A, 칼럼명B)
               대상 데이터에 대해, 칼럼A와 B에 따라
               1) 칼럼(A, B)에 따른 소계를 자동 계산하여 결과 테이블 중간에 출력
               2) 전체 총계를 자동 계산하여 결과 테이블 가장 아래에 출력
       CUBE
           GROUP BY CUBE(칼럼명A, 칼럼명B)
               대상 데이터에 대해, 칼럼A와 B에 따라
               1) 칼럼(A, B)에 따른 소계를 자동 계산하여 결과테이블 중간에 출력
               2) 전체 총계를 자동 계산하여 결과 테이블의 가장 윗행에 출력
               3) 칼럼 A별 소계, 칼럼 B별 소계를 자동 계산하여 결과 테이블 가장 윗행에 출력

       ※ ROLLUP은 A의 소계만 나오고 CUBE는 A와 B의 소계가 나온다.

SEQUENCE
 - 일련번호
       중복되면 안되고 계속해서 번호가 증가
 - 테이블 내의 유일한 숫자를 자동으로 생성하는 자동 번호 발생기
       기본키로 사용하면 사용자의 부담이 줄어든다.
           ex) CREATE TABLE 테이블명(
	        test number(3));
	        INSERT INTO 테이블명 VALUES(시퀀스명.NEXTVAL);

 - 시퀀스 생성하기
       CREATE SEQUENCE 시퀀스명
           [START WITH n] : 시작하는 숫자,
		          DEFAULT는 1
           [INCREMENT BY n] : 증가하는 숫자,
			 DEFAULT는 1
           [MAXVALUE n | NOMAXVALUE] : 최대 숫자
				     DEFAULT는 NOMAXVALUE
           [MINVALUE n | NOMINVALUE] : 최소 숫자
				   DEFAULT는 NOMINVALUE
           [CYCLE | NOCYCLE] : 최대가 되면 최소로,
			 DEFAULT는 NOCYCLE
           [CACHE n | NOCACHE] : 메모리에 시퀀스 값을 미리 할당하는지 안하는지,
			      시퀀스로 번호를 생성할 때마다 번호를 계산해서 뽑게 되면
			          시간이 많이 걸리기 때문에 
                                              CACHE 20하면 번호 20개를 미리 뽑아놓으라는 의미
           ※ ','로 구분하지 않음

 - 시퀀스 삭제하기
       DROP SEQUENCE 시퀀스명;

 - 시퀀스 수정하기
       ALTER SEQUENCE 시퀀스명 
           수정할 내용
               ex) INCREMENT BY 20
                    CYCLE
       단, 시작 위치는 수정할 수 없다.
       INCREMENT BY를 수정하면 시작 위치가 1로 바뀐다.

 - NEXTVAL
       현재 시퀀스의 다음 값 구하기
       다음 포인터가 어디를 가르키는지?
       주로 INSERT문에 많이 사용된다.

 - CURRVAL
       현재 시퀀스의 값 구하기
       현재 포인터가 어디를 가르키는지?
       시퀀스를 생성하고 NEXTVAL을 하지 않고 CURRVAL을 하면 
           시작 위치에서 한 번도 이동하지 않아서 포인터 위치를 알 수 없으므로 오류 발생

인덱스
 - SQL 명령문의 처리 속도를 향상시키기 위해 칼럼에 대해 생성하는 오라클 객체
 - 오라클에서 인덱스의 내부 구조는 보통 B(2진) 트리 형식으로 구성
 - 인덱스가 생성되면 테이블과 매핑된 또 다른 테이블이 하나 생성된다.
       인덱스에서 먼저 데이터들을 찾은 다음 
       매핑된 테이블로 가서 나머지 데이터들을 꺼내오는 방식
 - 장점
       정렬, 검색 속도가 빨라짐
       시스템에 걸리는 부하를 줄여서 시스템 전체 성능을 향상
 - 단점
       인덱스를 위한 추가적인 공간이 필요
       인덱스를 생성하는데 시간이 걸림
       데이터 변경 작업이 자주 일어날 경우 오히려 성능이 저하된다.
                   (INSERT, UPDATE, DELETE)

 - 인덱스를 사용하면 효율적인 경우
       1) 테이블에 행의 수가 많은 경우
       2) WHERE절에 칼럼이 많이 사용되는 경우
       3) 검색 결과가 전체 데이터의 2~4%일 경우
       4) JOIN에 자주 사용되는 칼럼이나 NULL을 포함하는 칼럼이 많은 경우
       5) ORDER BY절에 자주 등장하는 칼럼을 인덱스로 지정
               인덱스는 정렬이 되서 저장되어 있기 때문에 
                따로 정렬을 할 필요가 없이 출력하면 된다.

 - 인덱스를 사용하면 비효율적인 경우
       1) 테이블에 행의 수가 적은 경우
       2) WHERE절에 해당 칼럼이 자주 사용되지 않는 경우
       3) 전체 결과가 전체 데이터의 10 ~ 15% 이상일 경우
       4) 테이블에 DML 작업이 많은 경우

 - 인덱스 생성하기 
       CREATE INDEX 인덱스명 ON 테이블명(칼럼명);
           칼럼을 기준으로 2진 트리를 만드는 것
 
 - 인덱스 제거하기
       DROP INDEX 인덱스명;

 - 인덱스 수정하기

 - 인덱스 정보 조회
       user_ind_columns

 - 인덱스의 종류
       고유 인덱스 : 유일키처럼 유일한 값을 갖는 칼럼에 대개 인덱스를 생성
		    데이터가 중복되는 칼럼은 고유 인덱스로 만들 수 없음
		    CREATE UNIQUE INDEX 인덱스명 ON 테이블명(칼럼명)

       비고유 인덱스 : 중복된 데이터를 갖는 칼럼에 대해 인덱스를 생성
		       CREATE INDEX 인덱스명 ON 테이블명(칼럼명)

       ※ 인덱스를 만든 칼럼으로 또 인덱스를 만들 순 없다.

       결합 인덱스 : 두개 이상의 칼럼으로 인덱스를 구성
		    CREATE INDEX 인덱스명 ON 테이블명(칼럼명1, 칼럼명2);
		        결합 인덱스이자 비 고유 인덱스
 		    이미 고유/비고유 인덱스로 만든 칼럼을 사용해서 결합 인덱스를 만들 수 있음
		        반대로 결합 인덱스로 만든 칼럼들로 고유/비고유 인덱스를 만들 수 있음
                            결합하는 칼럼의 순서가 중요
		         WHERE절에서 equal 조건으로 많이 쓰는 칼럼들이 앞으로 오는게 효율적
		         분별력이 높은 칼럼이 앞으로 오는게 효율적

       함수 기반 인덱스 : 검색 조건으로 WHERE sal = 300이 아니라
		           WHERE sal * 12 = 3600과 같이
		           WHERE절에 산술 표현 또는 함수를 사용하는 경우 인덱스를 타지 못함
                                       테이블명(칼럼명) 한거에 계산식을 하면 인덱스가 적용 안됨
		           SUBSTR도 마찬가지
		           이러한 경우 수식이나 함수를 적용하여 인덱스를 만들 수 있다.
		           CREATE INDEX 인덱스명 ON 테이블명(칼럼명 * 12);

 - 인덱스 수정하기
       ALTER INDEX 인덱스명 REBUILD;
           구조를 수정하는게 아님
           인덱스가 생성된 후 테이블에 새로운 행이 추가, 삭제, 변경되는 경우
           이진 트리를 다시 구성하는 것
           인덱스로 만든 칼럼의 데이터를 재구축
		           
사용자 관리
 - 관리자 계정
       sys : 모든 권한
       system : 계정에 대한 모든 권한

 - 현재 접속한 사용자 이름 
       SHOW USER;

 - 사용자 생성
       CREATE USER 유저ID IDENTIFIED BY 유저PW;
		           
SET TIMING ON
 - 작업 시간을 보는 것

Oracle 11g express edition 제한 사항
 - 시스템에서 하나의 CPU 코어만 사용
 - 최대 1GB RAM 사용
 - 11.2에 최대 4GB 데이터, 11GB의 데이터 저장
 - 분할 된 개체
 - 문자셋 변경
 - 구체화 된 뷰 질의 재 작성